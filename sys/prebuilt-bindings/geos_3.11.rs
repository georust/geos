/* automatically generated by rust-bindgen 0.60.1 */

pub const GEOS_VERSION_MAJOR: u32 = 3;
pub const GEOS_VERSION_MINOR: u32 = 11;
pub const GEOS_VERSION: &[u8; 12usize] = b"3.11.0beta2\0";
pub const GEOS_JTS_PORT: &[u8; 7usize] = b"1.18.0\0";
pub const GEOS_CAPI_VERSION_MAJOR: u32 = 1;
pub const GEOS_CAPI_VERSION_MINOR: u32 = 16;
pub const GEOS_CAPI_VERSION_PATCH: u32 = 0;
pub const GEOS_CAPI_VERSION: &[u8; 24usize] = b"3.11.0beta2-CAPI-1.16.0\0";
pub const GEOS_CAPI_FIRST_INTERFACE: u32 = 1;
pub const GEOS_CAPI_LAST_INTERFACE: u32 = 17;
pub type wchar_t = libc::c_int;
pub type max_align_t = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GEOSContextHandle_HS {
    _unused: [u8; 0],
}
#[doc = " Type returned by GEOS_init_r(), for use in multi-threaded"]
#[doc = " applications."]
#[doc = ""]
#[doc = " There should be only one GEOSContextHandle_t per thread."]
pub type GEOSContextHandle_t = *mut GEOSContextHandle_HS;
#[doc = " Callback function for passing GEOS error messages to parent process."]
#[doc = ""]
#[doc = " Set the GEOSMessageHandler for error and notice messages in \\ref initGEOS"]
#[doc = " for single-threaded programs, or using \\ref initGEOS_r for threaded"]
#[doc = " programs"]
#[doc = ""]
#[doc = " \\param fmt the message format template"]
pub type GEOSMessageHandler =
    ::std::option::Option<unsafe extern "C" fn(fmt: *const libc::c_char, ...)>;
#[doc = " A GEOS message handler function."]
#[doc = ""]
#[doc = " \\param message the message contents"]
#[doc = " \\param userdata the user data pointer that was passed to GEOS when"]
#[doc = " registering this message handler."]
#[doc = ""]
#[doc = " \\see GEOSContext_setErrorMessageHandler"]
#[doc = " \\see GEOSContext_setNoticeMessageHandler"]
pub type GEOSMessageHandler_r = ::std::option::Option<
    unsafe extern "C" fn(message: *const libc::c_char, userdata: *mut libc::c_void),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GEOSGeom_t {
    _unused: [u8; 0],
}
#[doc = " Geometry generic type. Geometry can be a point, linestring, polygon,"]
#[doc = " multipoint, multilinestring, multipolygon, or geometrycollection."]
#[doc = " Geometry type can be read with \\ref GEOSGeomTypeId. Most functions"]
#[doc = " in GEOS either have GEOSGeometry* as a parameter or a return type."]
#[doc = " \\see GEOSGeom_createPoint"]
#[doc = " \\see GEOSGeom_createLineString"]
#[doc = " \\see GEOSGeom_createPolygon"]
#[doc = " \\see GEOSGeom_createCollection"]
#[doc = " \\see GEOSGeom_destroy"]
pub type GEOSGeometry = GEOSGeom_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GEOSPrepGeom_t {
    _unused: [u8; 0],
}
#[doc = " Prepared geometry type."]
#[doc = " \\see GEOSPrepare()"]
#[doc = " \\see GEOSPreparedGeom_destroy()"]
pub type GEOSPreparedGeometry = GEOSPrepGeom_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GEOSCoordSeq_t {
    _unused: [u8; 0],
}
#[doc = " Coordinate sequence."]
#[doc = " \\see GEOSCoordSeq_create()"]
#[doc = " \\see GEOSCoordSeq_destroy()"]
pub type GEOSCoordSequence = GEOSCoordSeq_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GEOSSTRtree_t {
    _unused: [u8; 0],
}
#[doc = " STRTree index."]
#[doc = " \\see GEOSSTRtree_create()"]
#[doc = " \\see GEOSSTRtree_destroy()"]
pub type GEOSSTRtree = GEOSSTRtree_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GEOSBufParams_t {
    _unused: [u8; 0],
}
#[doc = " Parameter object for buffering."]
#[doc = " \\see GEOSBufferParams_create()"]
#[doc = " \\see GEOSBufferParams_destroy()"]
pub type GEOSBufferParams = GEOSBufParams_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GEOSMakeValidParams_t {
    _unused: [u8; 0],
}
#[doc = " Parameter object for validity enforcement."]
#[doc = " \\see GEOSMakeValidParams_create()"]
#[doc = " \\see GEOSMakeValidParams_destroy()"]
pub type GEOSMakeValidParams = GEOSMakeValidParams_t;
#[doc = " \\cond"]
pub type GEOSGeom = *mut GEOSGeometry;
pub type GEOSCoordSeq = *mut GEOSCoordSequence;
#[doc = " Point"]
pub const GEOSGeomTypes_GEOS_POINT: GEOSGeomTypes = 0;
#[doc = " Linestring"]
pub const GEOSGeomTypes_GEOS_LINESTRING: GEOSGeomTypes = 1;
#[doc = " Linear ring, used within polygons"]
pub const GEOSGeomTypes_GEOS_LINEARRING: GEOSGeomTypes = 2;
#[doc = " Polygon"]
pub const GEOSGeomTypes_GEOS_POLYGON: GEOSGeomTypes = 3;
#[doc = " Multipoint, a homogeneous collection of points"]
pub const GEOSGeomTypes_GEOS_MULTIPOINT: GEOSGeomTypes = 4;
#[doc = " Multilinestring, a homogeneous collection of linestrings"]
pub const GEOSGeomTypes_GEOS_MULTILINESTRING: GEOSGeomTypes = 5;
#[doc = " Multipolygon, a homogeneous collection of polygons"]
pub const GEOSGeomTypes_GEOS_MULTIPOLYGON: GEOSGeomTypes = 6;
#[doc = " Geometry collection, a heterogeneous collection of geometry"]
pub const GEOSGeomTypes_GEOS_GEOMETRYCOLLECTION: GEOSGeomTypes = 7;
#[doc = " Geometry type number, used by functions returning or"]
#[doc = " consuming geometry types."]
#[doc = ""]
#[doc = " \\see GEOSGeomType"]
#[doc = " \\see GEOSGeomTypeId"]
pub type GEOSGeomTypes = libc::c_uint;
#[doc = " Big Endian"]
pub const GEOSWKBByteOrders_GEOS_WKB_XDR: GEOSWKBByteOrders = 0;
#[doc = " Little Endian"]
pub const GEOSWKBByteOrders_GEOS_WKB_NDR: GEOSWKBByteOrders = 1;
#[doc = " Well-known binary byte orders used when"]
#[doc = " writing to WKB."]
#[doc = ""]
#[doc = " \\see GEOSWKBWriter_setByteOrder"]
pub type GEOSWKBByteOrders = libc::c_uint;
#[doc = " Extended"]
pub const GEOSWKBFlavors_GEOS_WKB_EXTENDED: GEOSWKBFlavors = 1;
#[doc = " ISO"]
pub const GEOSWKBFlavors_GEOS_WKB_ISO: GEOSWKBFlavors = 2;
#[doc = " Well-known binary flavors to use"]
#[doc = " when writing to WKB. ISO flavour is"]
#[doc = " more standard. Extended flavour supports"]
#[doc = " 3D and SRID embedding. GEOS reads both"]
#[doc = " transparently."]
#[doc = ""]
#[doc = " \\see GEOSWKBWriter_setFlavor"]
pub type GEOSWKBFlavors = libc::c_uint;
#[doc = " Callback function for use in spatial index search calls. Pass into"]
#[doc = " the query function and handle query results as the index"]
#[doc = " returns them."]
#[doc = ""]
#[doc = " \\see GEOSSTRtree_query"]
pub type GEOSQueryCallback = ::std::option::Option<
    unsafe extern "C" fn(item: *mut libc::c_void, userdata: *mut libc::c_void),
>;
#[doc = " Callback function for use in spatial index nearest neighbor calculations."]
#[doc = " Allows custom distance to be calculated between items in the"]
#[doc = " index. Is passed two items, and sets the calculated distance"]
#[doc = " between the items into the distance pointer. Extra data for the"]
#[doc = " calculation can be passed via the userdata."]
#[doc = ""]
#[doc = " \\param item1 first of the pair of items to calculate distance between"]
#[doc = " \\param item2 second of the pair of items to calculate distance between"]
#[doc = " \\param distance the distance between the items here"]
#[doc = " \\param userdata extra data for the calculation"]
#[doc = ""]
#[doc = " \\return zero if distance calculation succeeded, non-zero otherwise"]
#[doc = ""]
#[doc = " \\see GEOSSTRtree_nearest_generic"]
#[doc = " \\see GEOSSTRtree_iterate"]
pub type GEOSDistanceCallback = ::std::option::Option<
    unsafe extern "C" fn(
        item1: *const libc::c_void,
        item2: *const libc::c_void,
        distance: *mut f64,
        userdata: *mut libc::c_void,
    ) -> libc::c_int,
>;
#[doc = " Callback function for use in GEOSGeom_transformXY."]
#[doc = " Allows custom function to be applied to x and y values for each coordinate"]
#[doc = " in a geometry.  Z values are unchanged by this function."]
#[doc = " Extra data for the calculation can be passed via the userdata."]
#[doc = ""]
#[doc = " \\param x coordinate value to be updated"]
#[doc = " \\param y coordinate value to be updated"]
#[doc = " \\param userdata extra data for the calculation"]
#[doc = ""]
#[doc = " \\return 1 if calculation succeeded, 0 on failure"]
pub type GEOSTransformXYCallback = ::std::option::Option<
    unsafe extern "C" fn(x: *mut f64, y: *mut f64, userdata: *mut libc::c_void) -> libc::c_int,
>;
#[doc = " Callback function for use in interruption. The callback will be invoked _before_ checking for"]
#[doc = " interruption, so can be used to request it."]
#[doc = ""]
#[doc = " \\see GEOS_interruptRegisterCallback"]
#[doc = " \\see GEOS_interruptRequest"]
#[doc = " \\see GEOS_interruptCancel"]
pub type GEOSInterruptCallback = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    #[doc = " Register a function to be called when processing is interrupted."]
    #[doc = " \\param cb Callback function to invoke"]
    #[doc = " \\return the previously configured callback"]
    #[doc = " \\see GEOSInterruptCallback"]
    pub fn GEOS_interruptRegisterCallback(cb: GEOSInterruptCallback) -> GEOSInterruptCallback;
}
extern "C" {
    #[doc = " Request safe interruption of operations"]
    pub fn GEOS_interruptRequest();
}
extern "C" {
    #[doc = " Cancel a pending interruption request"]
    pub fn GEOS_interruptCancel();
}
extern "C" {
    #[doc = " Initialize a context for this thread. Pass this context into"]
    #[doc = " your other calls of `*_r` functions."]
    #[doc = " \\return a GEOS context for this thread"]
    pub fn GEOS_init_r() -> GEOSContextHandle_t;
}
extern "C" {
    #[doc = " Free the memory associated with a \\ref GEOSContextHandle_t"]
    #[doc = " when you are finished calling GEOS functions."]
    #[doc = " \\param handle to be freed"]
    pub fn GEOS_finish_r(handle: GEOSContextHandle_t);
}
extern "C" {
    #[doc = " Set the notice handler callback function for run-time notice messages."]
    #[doc = " \\param extHandle the context returned by \\ref GEOS_init_r."]
    #[doc = " \\param nf the handler callback"]
    #[doc = " \\return the previously configured message handler or NULL if no message handler was configured"]
    pub fn GEOSContext_setNoticeHandler_r(
        extHandle: GEOSContextHandle_t,
        nf: GEOSMessageHandler,
    ) -> GEOSMessageHandler;
}
extern "C" {
    #[doc = " Set the notice handler callback function for run-time error messages."]
    #[doc = " \\param extHandle the GEOS context from \\ref GEOS_init_r"]
    #[doc = " \\param ef the handler callback"]
    #[doc = " \\return the previously configured message handler or NULL if no message handler was configured"]
    pub fn GEOSContext_setErrorHandler_r(
        extHandle: GEOSContextHandle_t,
        ef: GEOSMessageHandler,
    ) -> GEOSMessageHandler;
}
extern "C" {
    #[doc = " Sets a notice message handler on the given GEOS context."]
    #[doc = " \\param extHandle the GEOS context from \\ref GEOS_init_r"]
    #[doc = " \\param nf the message handler"]
    #[doc = " \\param userData optional user data pointer that will be passed to the message handler"]
    #[doc = " \\return the previously configured message handler or NULL if no message handler was configured"]
    pub fn GEOSContext_setNoticeMessageHandler_r(
        extHandle: GEOSContextHandle_t,
        nf: GEOSMessageHandler_r,
        userData: *mut libc::c_void,
    ) -> GEOSMessageHandler_r;
}
extern "C" {
    #[doc = " Sets an error message handler on the given GEOS context."]
    #[doc = ""]
    #[doc = " \\param extHandle the GEOS context"]
    #[doc = " \\param ef the message handler"]
    #[doc = " \\param userData optional user data pointer that will be passed to the message handler"]
    #[doc = ""]
    #[doc = " \\return the previously configured message handler or NULL if no message handler was configured"]
    pub fn GEOSContext_setErrorMessageHandler_r(
        extHandle: GEOSContextHandle_t,
        ef: GEOSMessageHandler_r,
        userData: *mut libc::c_void,
    ) -> GEOSMessageHandler_r;
}
extern "C" {
    #[doc = " \\see GEOSCoordSeq_create"]
    pub fn GEOSCoordSeq_create_r(
        handle: GEOSContextHandle_t,
        size: libc::c_uint,
        dims: libc::c_uint,
    ) -> *mut GEOSCoordSequence;
}
extern "C" {
    #[doc = " \\see GEOSCoordSeq_copyFromBuffer"]
    pub fn GEOSCoordSeq_copyFromBuffer_r(
        handle: GEOSContextHandle_t,
        buf: *const f64,
        size: libc::c_uint,
        hasZ: libc::c_int,
        hasM: libc::c_int,
    ) -> *mut GEOSCoordSequence;
}
extern "C" {
    #[doc = " \\see GEOSCoordSeq_copyFromArrays"]
    pub fn GEOSCoordSeq_copyFromArrays_r(
        handle: GEOSContextHandle_t,
        x: *const f64,
        y: *const f64,
        z: *const f64,
        m: *const f64,
        size: libc::c_uint,
    ) -> *mut GEOSCoordSequence;
}
extern "C" {
    #[doc = " \\see GEOSCoordSeq_copyToBuffer"]
    pub fn GEOSCoordSeq_copyToBuffer_r(
        handle: GEOSContextHandle_t,
        s: *const GEOSCoordSequence,
        buf: *mut f64,
        hasZ: libc::c_int,
        hasM: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSCoordSeq_copyToArrays"]
    pub fn GEOSCoordSeq_copyToArrays_r(
        handle: GEOSContextHandle_t,
        s: *const GEOSCoordSequence,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        m: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSCoordSeq_clone"]
    pub fn GEOSCoordSeq_clone_r(
        handle: GEOSContextHandle_t,
        s: *const GEOSCoordSequence,
    ) -> *mut GEOSCoordSequence;
}
extern "C" {
    #[doc = " \\see GEOSCoordSeq_destroy"]
    pub fn GEOSCoordSeq_destroy_r(handle: GEOSContextHandle_t, s: *mut GEOSCoordSequence);
}
extern "C" {
    #[doc = " \\see GEOSCoordSeq_setX"]
    pub fn GEOSCoordSeq_setX_r(
        handle: GEOSContextHandle_t,
        s: *mut GEOSCoordSequence,
        idx: libc::c_uint,
        val: f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSCoordSeq_setY"]
    pub fn GEOSCoordSeq_setY_r(
        handle: GEOSContextHandle_t,
        s: *mut GEOSCoordSequence,
        idx: libc::c_uint,
        val: f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSCoordSeq_setZ"]
    pub fn GEOSCoordSeq_setZ_r(
        handle: GEOSContextHandle_t,
        s: *mut GEOSCoordSequence,
        idx: libc::c_uint,
        val: f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSCoordSeq_setXY"]
    pub fn GEOSCoordSeq_setXY_r(
        handle: GEOSContextHandle_t,
        s: *mut GEOSCoordSequence,
        idx: libc::c_uint,
        x: f64,
        y: f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSCoordSeq_setXYZ"]
    pub fn GEOSCoordSeq_setXYZ_r(
        handle: GEOSContextHandle_t,
        s: *mut GEOSCoordSequence,
        idx: libc::c_uint,
        x: f64,
        y: f64,
        z: f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSCoordSeq_setOrdinate"]
    pub fn GEOSCoordSeq_setOrdinate_r(
        handle: GEOSContextHandle_t,
        s: *mut GEOSCoordSequence,
        idx: libc::c_uint,
        dim: libc::c_uint,
        val: f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSCoordSeq_getX"]
    pub fn GEOSCoordSeq_getX_r(
        handle: GEOSContextHandle_t,
        s: *const GEOSCoordSequence,
        idx: libc::c_uint,
        val: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSCoordSeq_getY"]
    pub fn GEOSCoordSeq_getY_r(
        handle: GEOSContextHandle_t,
        s: *const GEOSCoordSequence,
        idx: libc::c_uint,
        val: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSCoordSeq_getZ"]
    pub fn GEOSCoordSeq_getZ_r(
        handle: GEOSContextHandle_t,
        s: *const GEOSCoordSequence,
        idx: libc::c_uint,
        val: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSCoordSeq_getXY"]
    pub fn GEOSCoordSeq_getXY_r(
        handle: GEOSContextHandle_t,
        s: *const GEOSCoordSequence,
        idx: libc::c_uint,
        x: *mut f64,
        y: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSCoordSeq_getXYZ"]
    pub fn GEOSCoordSeq_getXYZ_r(
        handle: GEOSContextHandle_t,
        s: *const GEOSCoordSequence,
        idx: libc::c_uint,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSCoordSeq_getOrdinate"]
    pub fn GEOSCoordSeq_getOrdinate_r(
        handle: GEOSContextHandle_t,
        s: *const GEOSCoordSequence,
        idx: libc::c_uint,
        dim: libc::c_uint,
        val: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSCoordSeq_getSize"]
    pub fn GEOSCoordSeq_getSize_r(
        handle: GEOSContextHandle_t,
        s: *const GEOSCoordSequence,
        size: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSCoordSeq_getDimensions"]
    pub fn GEOSCoordSeq_getDimensions_r(
        handle: GEOSContextHandle_t,
        s: *const GEOSCoordSequence,
        dims: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSCoordSeq_isCCW"]
    pub fn GEOSCoordSeq_isCCW_r(
        handle: GEOSContextHandle_t,
        s: *const GEOSCoordSequence,
        is_ccw: *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSProject"]
    pub fn GEOSProject_r(
        handle: GEOSContextHandle_t,
        line: *const GEOSGeometry,
        point: *const GEOSGeometry,
    ) -> f64;
}
extern "C" {
    #[doc = " \\see GEOSInterpolate"]
    pub fn GEOSInterpolate_r(
        handle: GEOSContextHandle_t,
        line: *const GEOSGeometry,
        d: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSProjectNormalized"]
    pub fn GEOSProjectNormalized_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        p: *const GEOSGeometry,
    ) -> f64;
}
extern "C" {
    #[doc = " \\see GEOSInterpolateNormalized"]
    pub fn GEOSInterpolateNormalized_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        d: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSBuffer"]
    pub fn GEOSBuffer_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        width: f64,
        quadsegs: libc::c_int,
    ) -> *mut GEOSGeometry;
}
#[doc = " End is rounded, with end point of original line in the centre of the round cap."]
pub const GEOSBufCapStyles_GEOSBUF_CAP_ROUND: GEOSBufCapStyles = 1;
#[doc = " End is flat, with end point of original line at the end of the buffer"]
pub const GEOSBufCapStyles_GEOSBUF_CAP_FLAT: GEOSBufCapStyles = 2;
#[doc = " End is flat, with end point of original line in the middle of a square enclosing that point"]
pub const GEOSBufCapStyles_GEOSBUF_CAP_SQUARE: GEOSBufCapStyles = 3;
#[doc = " Cap styles control the ends of buffered lines."]
#[doc = " \\see GEOSBuffer"]
pub type GEOSBufCapStyles = libc::c_uint;
#[doc = " Join is rounded, essentially each line is terminated"]
#[doc = " in a round cap. Form round corner."]
pub const GEOSBufJoinStyles_GEOSBUF_JOIN_ROUND: GEOSBufJoinStyles = 1;
#[doc = " Join is flat, with line between buffer edges,"]
#[doc = " through the join point. Forms flat corner."]
pub const GEOSBufJoinStyles_GEOSBUF_JOIN_MITRE: GEOSBufJoinStyles = 2;
#[doc = " Join is the point at which the two buffer edges intersect."]
#[doc = " Forms sharp corner."]
pub const GEOSBufJoinStyles_GEOSBUF_JOIN_BEVEL: GEOSBufJoinStyles = 3;
#[doc = " Join styles control the buffer shape at bends in a line."]
#[doc = " \\see GEOSBuffer"]
pub type GEOSBufJoinStyles = libc::c_uint;
extern "C" {
    #[doc = " \\see GEOSBufferParams_create"]
    pub fn GEOSBufferParams_create_r(handle: GEOSContextHandle_t) -> *mut GEOSBufferParams;
}
extern "C" {
    #[doc = " \\see GEOSBufferParams_destroy"]
    pub fn GEOSBufferParams_destroy_r(handle: GEOSContextHandle_t, parms: *mut GEOSBufferParams);
}
extern "C" {
    #[doc = " \\see GEOSBufferParams_setEndCapStyle"]
    pub fn GEOSBufferParams_setEndCapStyle_r(
        handle: GEOSContextHandle_t,
        p: *mut GEOSBufferParams,
        style: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSBufferParams_setJoinStyle"]
    pub fn GEOSBufferParams_setJoinStyle_r(
        handle: GEOSContextHandle_t,
        p: *mut GEOSBufferParams,
        joinStyle: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSBufferParams_setMitreLimit"]
    pub fn GEOSBufferParams_setMitreLimit_r(
        handle: GEOSContextHandle_t,
        p: *mut GEOSBufferParams,
        mitreLimit: f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSBufferParams_setQuadrantSegments"]
    pub fn GEOSBufferParams_setQuadrantSegments_r(
        handle: GEOSContextHandle_t,
        p: *mut GEOSBufferParams,
        quadSegs: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSBufferParams_setSingleSided"]
    pub fn GEOSBufferParams_setSingleSided_r(
        handle: GEOSContextHandle_t,
        p: *mut GEOSBufferParams,
        singleSided: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSBufferWithParams"]
    pub fn GEOSBufferWithParams_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        p: *const GEOSBufferParams,
        width: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSBufferWithStyle"]
    pub fn GEOSBufferWithStyle_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        width: f64,
        quadsegs: libc::c_int,
        endCapStyle: libc::c_int,
        joinStyle: libc::c_int,
        mitreLimit: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSDensify"]
    pub fn GEOSDensify_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        tolerance: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSOffsetCurve"]
    pub fn GEOSOffsetCurve_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        width: f64,
        quadsegs: libc::c_int,
        joinStyle: libc::c_int,
        mitreLimit: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSGeom_createPoint"]
    pub fn GEOSGeom_createPoint_r(
        handle: GEOSContextHandle_t,
        s: *mut GEOSCoordSequence,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSGeom_createPointFromXY"]
    pub fn GEOSGeom_createPointFromXY_r(
        handle: GEOSContextHandle_t,
        x: f64,
        y: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSGeom_createEmptyPoint"]
    pub fn GEOSGeom_createEmptyPoint_r(handle: GEOSContextHandle_t) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSGeom_createLinearRing"]
    pub fn GEOSGeom_createLinearRing_r(
        handle: GEOSContextHandle_t,
        s: *mut GEOSCoordSequence,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSGeom_createLineString"]
    pub fn GEOSGeom_createLineString_r(
        handle: GEOSContextHandle_t,
        s: *mut GEOSCoordSequence,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSGeom_createEmptyLineString"]
    pub fn GEOSGeom_createEmptyLineString_r(handle: GEOSContextHandle_t) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSGeom_createEmptyPolygon"]
    pub fn GEOSGeom_createEmptyPolygon_r(handle: GEOSContextHandle_t) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSGeom_createPolygon"]
    pub fn GEOSGeom_createPolygon_r(
        handle: GEOSContextHandle_t,
        shell: *mut GEOSGeometry,
        holes: *mut *mut GEOSGeometry,
        nholes: libc::c_uint,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSGeom_createCollection"]
    pub fn GEOSGeom_createCollection_r(
        handle: GEOSContextHandle_t,
        type_: libc::c_int,
        geoms: *mut *mut GEOSGeometry,
        ngeoms: libc::c_uint,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSGeom_createEmptyCollection"]
    pub fn GEOSGeom_createEmptyCollection_r(
        handle: GEOSContextHandle_t,
        type_: libc::c_int,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSGeom_createRectangle"]
    pub fn GEOSGeom_createRectangle_r(
        handle: GEOSContextHandle_t,
        xmin: f64,
        ymin: f64,
        xmax: f64,
        ymax: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSGeom_clone"]
    pub fn GEOSGeom_clone_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSGeom_destroy"]
    pub fn GEOSGeom_destroy_r(handle: GEOSContextHandle_t, g: *mut GEOSGeometry);
}
extern "C" {
    #[doc = " \\see GEOSEnvelope"]
    pub fn GEOSEnvelope_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry)
        -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSIntersection"]
    pub fn GEOSIntersection_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSIntersectionPrec"]
    pub fn GEOSIntersectionPrec_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        gridSize: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSConvexHull"]
    pub fn GEOSConvexHull_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSConcaveHull"]
    pub fn GEOSConcaveHull_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        ratio: f64,
        allowHoles: libc::c_uint,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSPolygonHullSimplify"]
    pub fn GEOSPolygonHullSimplify_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        isOuter: libc::c_uint,
        vertexNumFraction: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSPolygonHullSimplifyByArea"]
    pub fn GEOSPolygonHullSimplifyMode_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        isOuter: libc::c_uint,
        parameterMode: libc::c_uint,
        parameter: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSConcaveHullOfPolygons"]
    pub fn GEOSConcaveHullOfPolygons_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        lengthRatio: f64,
        isTight: libc::c_uint,
        isHolesAllowed: libc::c_uint,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSMinimumRotatedRectangle"]
    pub fn GEOSMinimumRotatedRectangle_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSMaximumInscribedCircle"]
    pub fn GEOSMaximumInscribedCircle_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        tolerance: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSLargestEmptyCircle"]
    pub fn GEOSLargestEmptyCircle_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        boundary: *const GEOSGeometry,
        tolerance: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSMinimumWidth"]
    pub fn GEOSMinimumWidth_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSMinimumClearanceLine"]
    pub fn GEOSMinimumClearanceLine_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSMinimumClearance"]
    pub fn GEOSMinimumClearance_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        distance: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSDifference"]
    pub fn GEOSDifference_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSDifferencePrec"]
    pub fn GEOSDifferencePrec_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        gridSize: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSSymDifference"]
    pub fn GEOSSymDifference_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSSymDifferencePrec"]
    pub fn GEOSSymDifferencePrec_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        gridSize: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSBoundary"]
    pub fn GEOSBoundary_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry)
        -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSUnion"]
    pub fn GEOSUnion_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSUnionPrec"]
    pub fn GEOSUnionPrec_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        gridSize: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSUnaryUnion"]
    pub fn GEOSUnaryUnion_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSUnaryUnionPrec"]
    pub fn GEOSUnaryUnionPrec_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        gridSize: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSCoverageUnion"]
    pub fn GEOSCoverageUnion_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSPointOnSurface"]
    pub fn GEOSPointOnSurface_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSGetCentroid"]
    pub fn GEOSGetCentroid_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSMinimumBoundingCircle"]
    pub fn GEOSMinimumBoundingCircle_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        radius: *mut f64,
        center: *mut *mut GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSNode"]
    pub fn GEOSNode_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSClipByRect"]
    pub fn GEOSClipByRect_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        xmin: f64,
        ymin: f64,
        xmax: f64,
        ymax: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSPolygonize"]
    pub fn GEOSPolygonize_r(
        handle: GEOSContextHandle_t,
        geoms: *const *const GEOSGeometry,
        ngeoms: libc::c_uint,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSPolygonize_valid"]
    pub fn GEOSPolygonize_valid_r(
        handle: GEOSContextHandle_t,
        geoms: *const *const GEOSGeometry,
        ngems: libc::c_uint,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSPolygonizer_getCutEdges"]
    pub fn GEOSPolygonizer_getCutEdges_r(
        handle: GEOSContextHandle_t,
        geoms: *const *const GEOSGeometry,
        ngeoms: libc::c_uint,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSPolygonize_full"]
    pub fn GEOSPolygonize_full_r(
        handle: GEOSContextHandle_t,
        input: *const GEOSGeometry,
        cuts: *mut *mut GEOSGeometry,
        dangles: *mut *mut GEOSGeometry,
        invalidRings: *mut *mut GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSBuildArea"]
    pub fn GEOSBuildArea_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSLineMerge"]
    pub fn GEOSLineMerge_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSLineMergeDirected"]
    pub fn GEOSLineMergeDirected_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSReverse"]
    pub fn GEOSReverse_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSSimplify"]
    pub fn GEOSSimplify_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        tolerance: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSTopologyPreserveSimplify"]
    pub fn GEOSTopologyPreserveSimplify_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        tolerance: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSGeom_extractUniquePoints"]
    pub fn GEOSGeom_extractUniquePoints_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSSharedPaths"]
    pub fn GEOSSharedPaths_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSSnap"]
    pub fn GEOSSnap_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        tolerance: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSDelaunayTriangulation"]
    pub fn GEOSDelaunayTriangulation_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        tolerance: f64,
        onlyEdges: libc::c_int,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSConstrainedDelaunayTriangulation"]
    pub fn GEOSConstrainedDelaunayTriangulation_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSVoronoiDiagram"]
    pub fn GEOSVoronoiDiagram_r(
        extHandle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        env: *const GEOSGeometry,
        tolerance: f64,
        onlyEdges: libc::c_int,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSSegmentIntersection"]
    pub fn GEOSSegmentIntersection_r(
        extHandle: GEOSContextHandle_t,
        ax0: f64,
        ay0: f64,
        ax1: f64,
        ay1: f64,
        bx0: f64,
        by0: f64,
        bx1: f64,
        by1: f64,
        cx: *mut f64,
        cy: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSDisjoint"]
    pub fn GEOSDisjoint_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSTouches"]
    pub fn GEOSTouches_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSIntersects"]
    pub fn GEOSIntersects_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSCrosses"]
    pub fn GEOSCrosses_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSWithin"]
    pub fn GEOSWithin_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSContains"]
    pub fn GEOSContains_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSOverlaps"]
    pub fn GEOSOverlaps_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSEquals"]
    pub fn GEOSEquals_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSEqualsExact"]
    pub fn GEOSEqualsExact_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        tolerance: f64,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSCovers"]
    pub fn GEOSCovers_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSCoveredBy"]
    pub fn GEOSCoveredBy_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSPrepare"]
    pub fn GEOSPrepare_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *const GEOSPreparedGeometry;
}
extern "C" {
    #[doc = " \\see GEOSPreparedGeom_destroy"]
    pub fn GEOSPreparedGeom_destroy_r(handle: GEOSContextHandle_t, g: *const GEOSPreparedGeometry);
}
extern "C" {
    #[doc = " \\see GEOSPreparedContains"]
    pub fn GEOSPreparedContains_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSPreparedContainsProperly"]
    pub fn GEOSPreparedContainsProperly_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSPreparedCoveredBy"]
    pub fn GEOSPreparedCoveredBy_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSPreparedCovers"]
    pub fn GEOSPreparedCovers_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSPreparedCrosses"]
    pub fn GEOSPreparedCrosses_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSPreparedDisjoint"]
    pub fn GEOSPreparedDisjoint_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSPreparedIntersects"]
    pub fn GEOSPreparedIntersects_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSPreparedOverlaps"]
    pub fn GEOSPreparedOverlaps_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSPreparedTouches"]
    pub fn GEOSPreparedTouches_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSPreparedWithin"]
    pub fn GEOSPreparedWithin_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSPreparedNearestPoints"]
    pub fn GEOSPreparedNearestPoints_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> *mut GEOSCoordSequence;
}
extern "C" {
    #[doc = " \\see GEOSPreparedDistance"]
    pub fn GEOSPreparedDistance_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSPreparedDistanceWithin"]
    pub fn GEOSPreparedDistanceWithin_r(
        handle: GEOSContextHandle_t,
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
        dist: f64,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSSTRtree_create"]
    pub fn GEOSSTRtree_create_r(
        handle: GEOSContextHandle_t,
        nodeCapacity: usize,
    ) -> *mut GEOSSTRtree;
}
extern "C" {
    #[doc = " \\see GEOSSTRtree_insert"]
    pub fn GEOSSTRtree_insert_r(
        handle: GEOSContextHandle_t,
        tree: *mut GEOSSTRtree,
        g: *const GEOSGeometry,
        item: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " \\see GEOSSTRtree_query"]
    pub fn GEOSSTRtree_query_r(
        handle: GEOSContextHandle_t,
        tree: *mut GEOSSTRtree,
        g: *const GEOSGeometry,
        callback: GEOSQueryCallback,
        userdata: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " \\see GEOSSTRtree_nearest"]
    pub fn GEOSSTRtree_nearest_r(
        handle: GEOSContextHandle_t,
        tree: *mut GEOSSTRtree,
        geom: *const GEOSGeometry,
    ) -> *const GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSSTRtree_nearest_generic"]
    pub fn GEOSSTRtree_nearest_generic_r(
        handle: GEOSContextHandle_t,
        tree: *mut GEOSSTRtree,
        item: *const libc::c_void,
        itemEnvelope: *const GEOSGeometry,
        distancefn: GEOSDistanceCallback,
        userdata: *mut libc::c_void,
    ) -> *const libc::c_void;
}
extern "C" {
    #[doc = " \\see GEOSSTRtree_iterate"]
    pub fn GEOSSTRtree_iterate_r(
        handle: GEOSContextHandle_t,
        tree: *mut GEOSSTRtree,
        callback: GEOSQueryCallback,
        userdata: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " \\see GEOSSTRtree_remove"]
    pub fn GEOSSTRtree_remove_r(
        handle: GEOSContextHandle_t,
        tree: *mut GEOSSTRtree,
        g: *const GEOSGeometry,
        item: *mut libc::c_void,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSSTRtree_destroy"]
    pub fn GEOSSTRtree_destroy_r(handle: GEOSContextHandle_t, tree: *mut GEOSSTRtree);
}
extern "C" {
    #[doc = " \\see GEOSisEmpty"]
    pub fn GEOSisEmpty_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSisSimple"]
    pub fn GEOSisSimple_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSisRing"]
    pub fn GEOSisRing_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSHasZ"]
    pub fn GEOSHasZ_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSisClosed"]
    pub fn GEOSisClosed_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry) -> libc::c_char;
}
#[doc = " See geos::algorithm::BoundaryNodeRule::getBoundaryRuleMod2()"]
pub const GEOSRelateBoundaryNodeRules_GEOSRELATE_BNR_MOD2: GEOSRelateBoundaryNodeRules = 1;
#[doc = " Same as \\ref GEOSRELATE_BNR_MOD2"]
pub const GEOSRelateBoundaryNodeRules_GEOSRELATE_BNR_OGC: GEOSRelateBoundaryNodeRules = 1;
#[doc = " See geos::algorithm::BoundaryNodeRule::getBoundaryEndPoint()"]
pub const GEOSRelateBoundaryNodeRules_GEOSRELATE_BNR_ENDPOINT: GEOSRelateBoundaryNodeRules = 2;
#[doc = " See geos::algorithm::BoundaryNodeRule::getBoundaryMultivalentEndPoint()"]
pub const GEOSRelateBoundaryNodeRules_GEOSRELATE_BNR_MULTIVALENT_ENDPOINT:
    GEOSRelateBoundaryNodeRules = 3;
#[doc = " See geos::algorithm::BoundaryNodeRule::getBoundaryMonovalentEndPoint()"]
pub const GEOSRelateBoundaryNodeRules_GEOSRELATE_BNR_MONOVALENT_ENDPOINT:
    GEOSRelateBoundaryNodeRules = 4;
#[doc = " Controls the behavior of the result of GEOSRelate when returning"]
#[doc = " DE9IM results for two geometries."]
pub type GEOSRelateBoundaryNodeRules = libc::c_uint;
extern "C" {
    #[doc = " \\see GEOSRelatePattern"]
    pub fn GEOSRelatePattern_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        pat: *const libc::c_char,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSRelate"]
    pub fn GEOSRelate_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSRelatePatternMatch"]
    pub fn GEOSRelatePatternMatch_r(
        handle: GEOSContextHandle_t,
        mat: *const libc::c_char,
        pat: *const libc::c_char,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSRelateBoundaryNodeRule"]
    pub fn GEOSRelateBoundaryNodeRule_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        bnr: libc::c_int,
    ) -> *mut libc::c_char;
}
#[doc = " Allow self-touching rings to form a hole in a polygon."]
pub const GEOSValidFlags_GEOSVALID_ALLOW_SELFTOUCHING_RING_FORMING_HOLE: GEOSValidFlags = 1;
#[doc = " Change behaviour of validity testing in \\ref GEOSisValidDetail"]
pub type GEOSValidFlags = libc::c_uint;
extern "C" {
    #[doc = " \\see GEOSisValid"]
    pub fn GEOSisValid_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSisValidReason"]
    pub fn GEOSisValidReason_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSisValidDetail"]
    pub fn GEOSisValidDetail_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        flags: libc::c_int,
        reason: *mut *mut libc::c_char,
        location: *mut *mut GEOSGeometry,
    ) -> libc::c_char;
}
#[doc = " Original method, combines all rings into"]
#[doc = "a set of noded lines and then extracts valid"]
#[doc = "polygons from that linework."]
pub const GEOSMakeValidMethods_GEOS_MAKE_VALID_LINEWORK: GEOSMakeValidMethods = 0;
#[doc = " Structured method, first makes all rings valid"]
#[doc = "then merges shells and subtracts holes from"]
#[doc = "shells to generate valid result. Assumes that"]
#[doc = "holes and shells are correctly categorized."]
pub const GEOSMakeValidMethods_GEOS_MAKE_VALID_STRUCTURE: GEOSMakeValidMethods = 1;
#[doc = " Algorithm to use when repairing invalid geometries."]
#[doc = ""]
#[doc = " \\see GEOSMakeValidWithParams"]
pub type GEOSMakeValidMethods = libc::c_uint;
extern "C" {
    #[doc = " \\see GEOSMakeValidParams_create"]
    pub fn GEOSMakeValidParams_create_r(extHandle: GEOSContextHandle_t)
        -> *mut GEOSMakeValidParams;
}
extern "C" {
    #[doc = " \\see GEOSMakeValidParams_destroy"]
    pub fn GEOSMakeValidParams_destroy_r(
        handle: GEOSContextHandle_t,
        parms: *mut GEOSMakeValidParams,
    );
}
extern "C" {
    #[doc = " \\see GEOSMakeValidParams_setKeepCollapsed"]
    pub fn GEOSMakeValidParams_setKeepCollapsed_r(
        handle: GEOSContextHandle_t,
        p: *mut GEOSMakeValidParams,
        style: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSMakeValidParams_setMethod"]
    pub fn GEOSMakeValidParams_setMethod_r(
        handle: GEOSContextHandle_t,
        p: *mut GEOSMakeValidParams,
        method: GEOSMakeValidMethods,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSMakeValid"]
    pub fn GEOSMakeValid_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSMakeValidWithParams"]
    pub fn GEOSMakeValidWithParams_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        makeValidParams: *const GEOSMakeValidParams,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSRemoveRepeatedPoints"]
    pub fn GEOSRemoveRepeatedPoints_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        tolerance: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSGeomType"]
    pub fn GEOSGeomType_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry)
        -> *mut libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSGeomTypeId"]
    pub fn GEOSGeomTypeId_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSGetSRID"]
    pub fn GEOSGetSRID_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSSetSRID"]
    pub fn GEOSSetSRID_r(handle: GEOSContextHandle_t, g: *mut GEOSGeometry, SRID: libc::c_int);
}
extern "C" {
    #[doc = " \\see GEOSGeom_getUserData"]
    pub fn GEOSGeom_getUserData_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " \\see GEOSGeom_setUserData"]
    pub fn GEOSGeom_setUserData_r(
        handle: GEOSContextHandle_t,
        g: *mut GEOSGeometry,
        userData: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " \\see GEOSGetNumGeometries"]
    pub fn GEOSGetNumGeometries_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSGetGeometryN"]
    pub fn GEOSGetGeometryN_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        n: libc::c_int,
    ) -> *const GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSNormalize"]
    pub fn GEOSNormalize_r(handle: GEOSContextHandle_t, g: *mut GEOSGeometry) -> libc::c_int;
}
#[doc = " The output is always valid. Collapsed geometry elements (including both polygons and lines) are removed."]
pub const GEOSPrecisionRules_GEOS_PREC_VALID_OUTPUT: GEOSPrecisionRules = 0;
#[doc = " Precision reduction is performed pointwise. Output geometry may be invalid due to collapse or self-intersection. (This might be better called \"GEOS_PREC_POINTWISE\" - the current name is historical.)"]
pub const GEOSPrecisionRules_GEOS_PREC_NO_TOPO: GEOSPrecisionRules = 1;
#[doc = " Like the default mode, except that collapsed linear geometry elements are preserved. Collapsed polygonal input elements are removed."]
pub const GEOSPrecisionRules_GEOS_PREC_KEEP_COLLAPSED: GEOSPrecisionRules = 2;
#[doc = " Controls the behavior of GEOSGeom_setPrecision()"]
#[doc = " when altering the precision of a geometry."]
pub type GEOSPrecisionRules = libc::c_uint;
extern "C" {
    #[doc = " \\see GEOSGeom_setPrecision"]
    pub fn GEOSGeom_setPrecision_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        gridSize: f64,
        flags: libc::c_int,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSGeom_getPrecision"]
    pub fn GEOSGeom_getPrecision_r(handle: GEOSContextHandle_t, g: *const GEOSGeometry) -> f64;
}
extern "C" {
    #[doc = " \\see GEOSGetNumInteriorRings"]
    pub fn GEOSGetNumInteriorRings_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSGeomGetNumPoints"]
    pub fn GEOSGeomGetNumPoints_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSGeomGetX"]
    pub fn GEOSGeomGetX_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        x: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSGeomGetY"]
    pub fn GEOSGeomGetY_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        y: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSGeomGetZ"]
    pub fn GEOSGeomGetZ_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        z: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSGetInteriorRingN"]
    pub fn GEOSGetInteriorRingN_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        n: libc::c_int,
    ) -> *const GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSGetExteriorRing"]
    pub fn GEOSGetExteriorRing_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *const GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSGetNumCoordinates"]
    pub fn GEOSGetNumCoordinates_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSGeom_getCoordSeq"]
    pub fn GEOSGeom_getCoordSeq_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *const GEOSCoordSequence;
}
extern "C" {
    #[doc = " \\see GEOSGeom_getDimensions"]
    pub fn GEOSGeom_getDimensions_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSGeom_getCoordinateDimension"]
    pub fn GEOSGeom_getCoordinateDimension_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSGeom_getXMin"]
    pub fn GEOSGeom_getXMin_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        value: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSGeom_getYMin"]
    pub fn GEOSGeom_getYMin_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        value: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSGeom_getXMax"]
    pub fn GEOSGeom_getXMax_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        value: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSGeom_getYMax"]
    pub fn GEOSGeom_getYMax_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        value: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSGeom_getExtent"]
    pub fn GEOSGeom_getExtent_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        xmin: *mut f64,
        ymin: *mut f64,
        xmax: *mut f64,
        ymax: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSGeomGetPointN"]
    pub fn GEOSGeomGetPointN_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        n: libc::c_int,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSGeomGetStartPoint"]
    pub fn GEOSGeomGetStartPoint_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSGeomGetEndPoint"]
    pub fn GEOSGeomGetEndPoint_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSArea"]
    pub fn GEOSArea_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        area: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSLength"]
    pub fn GEOSLength_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        length: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSDistance"]
    pub fn GEOSDistance_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSDistanceWithin"]
    pub fn GEOSDistanceWithin_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        dist: f64,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSDistanceIndexed"]
    pub fn GEOSDistanceIndexed_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSHausdorffDistance"]
    pub fn GEOSHausdorffDistance_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSHausdorffDistanceDensify"]
    pub fn GEOSHausdorffDistanceDensify_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        densifyFrac: f64,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSFrechetDistance"]
    pub fn GEOSFrechetDistance_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSFrechetDistanceDensify"]
    pub fn GEOSFrechetDistanceDensify_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        densifyFrac: f64,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSHilbertCode"]
    pub fn GEOSHilbertCode_r(
        handle: GEOSContextHandle_t,
        geom: *const GEOSGeometry,
        extent: *const GEOSGeometry,
        level: libc::c_uint,
        code: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSGeomGetLength"]
    pub fn GEOSGeomGetLength_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        length: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSNearestPoints"]
    pub fn GEOSNearestPoints_r(
        handle: GEOSContextHandle_t,
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> *mut GEOSCoordSequence;
}
extern "C" {
    #[doc = " \\see GEOSGeom_transformXY"]
    pub fn GEOSGeom_transformXY_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        callback: GEOSTransformXYCallback,
        userdata: *mut libc::c_void,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSOrientationIndex"]
    pub fn GEOSOrientationIndex_r(
        handle: GEOSContextHandle_t,
        Ax: f64,
        Ay: f64,
        Bx: f64,
        By: f64,
        Px: f64,
        Py: f64,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GEOSWKTReader_t {
    _unused: [u8; 0],
}
#[doc = " Reader object to read Well-Known Text (WKT) format and construct Geometry."]
#[doc = " \\see GEOSWKTReader_create"]
#[doc = " \\see GEOSWKTReader_create_r"]
pub type GEOSWKTReader = GEOSWKTReader_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GEOSWKTWriter_t {
    _unused: [u8; 0],
}
#[doc = " Writer object to turn Geometry into Well-Known Text (WKT)."]
#[doc = " \\see GEOSWKTWriter_create"]
#[doc = " \\see GEOSWKTWriter_create_r"]
pub type GEOSWKTWriter = GEOSWKTWriter_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GEOSWKBReader_t {
    _unused: [u8; 0],
}
#[doc = " Reader object to read Well-Known Binary (WKB) format and construct Geometry."]
#[doc = " \\see GEOSWKBReader_create"]
#[doc = " \\see GEOSWKBReader_create_r"]
pub type GEOSWKBReader = GEOSWKBReader_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GEOSWKBWriter_t {
    _unused: [u8; 0],
}
#[doc = " Writer object to turn Geometry into Well-Known Binary (WKB)."]
#[doc = " \\see GEOSWKBWriter_create"]
#[doc = " \\see GEOSWKBWriter_create_r"]
pub type GEOSWKBWriter = GEOSWKBWriter_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GEOSGeoJSONReader_t {
    _unused: [u8; 0],
}
#[doc = " Reader object to read GeoJSON format and construct a Geometry."]
#[doc = " \\see GEOSGeoJSONReader_create"]
#[doc = " \\see GEOSGeoJSONReader_create_r"]
pub type GEOSGeoJSONReader = GEOSGeoJSONReader_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GEOSGeoJSONWriter_t {
    _unused: [u8; 0],
}
#[doc = " Writer object to turn a Geometry into GeoJSON."]
#[doc = " \\see GEOSGeoJSONReader_create"]
#[doc = " \\see GEOSGeoJSONReader_create_r"]
pub type GEOSGeoJSONWriter = GEOSGeoJSONWriter_t;
extern "C" {
    #[doc = " \\see GEOSWKTReader_create"]
    pub fn GEOSWKTReader_create_r(handle: GEOSContextHandle_t) -> *mut GEOSWKTReader;
}
extern "C" {
    #[doc = " \\see GEOSWKTReader_destroy"]
    pub fn GEOSWKTReader_destroy_r(handle: GEOSContextHandle_t, reader: *mut GEOSWKTReader);
}
extern "C" {
    #[doc = " \\see GEOSWKTReader_read"]
    pub fn GEOSWKTReader_read_r(
        handle: GEOSContextHandle_t,
        reader: *mut GEOSWKTReader,
        wkt: *const libc::c_char,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSWKTReader_create"]
    pub fn GEOSWKTWriter_create_r(handle: GEOSContextHandle_t) -> *mut GEOSWKTWriter;
}
extern "C" {
    #[doc = " \\see GEOSWKTWriter_destroy"]
    pub fn GEOSWKTWriter_destroy_r(handle: GEOSContextHandle_t, writer: *mut GEOSWKTWriter);
}
extern "C" {
    #[doc = " \\see GEOSWKTWriter_write"]
    pub fn GEOSWKTWriter_write_r(
        handle: GEOSContextHandle_t,
        writer: *mut GEOSWKTWriter,
        g: *const GEOSGeometry,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSWKTWriter_setTrim"]
    pub fn GEOSWKTWriter_setTrim_r(
        handle: GEOSContextHandle_t,
        writer: *mut GEOSWKTWriter,
        trim: libc::c_char,
    );
}
extern "C" {
    #[doc = " \\see GEOSWKTWriter_setRoundingPrecision"]
    pub fn GEOSWKTWriter_setRoundingPrecision_r(
        handle: GEOSContextHandle_t,
        writer: *mut GEOSWKTWriter,
        precision: libc::c_int,
    );
}
extern "C" {
    #[doc = " \\see GEOSWKTWriter_setOutputDimension"]
    pub fn GEOSWKTWriter_setOutputDimension_r(
        handle: GEOSContextHandle_t,
        writer: *mut GEOSWKTWriter,
        dim: libc::c_int,
    );
}
extern "C" {
    #[doc = " \\see GEOSWKTWriter_getOutputDimension"]
    pub fn GEOSWKTWriter_getOutputDimension_r(
        handle: GEOSContextHandle_t,
        writer: *mut GEOSWKTWriter,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSWKTWriter_setOld3D"]
    pub fn GEOSWKTWriter_setOld3D_r(
        handle: GEOSContextHandle_t,
        writer: *mut GEOSWKTWriter,
        useOld3D: libc::c_int,
    );
}
extern "C" {
    #[doc = " \\see GEOSWKBReader_create"]
    pub fn GEOSWKBReader_create_r(handle: GEOSContextHandle_t) -> *mut GEOSWKBReader;
}
extern "C" {
    #[doc = " \\see GEOSWKBReader_destroy"]
    pub fn GEOSWKBReader_destroy_r(handle: GEOSContextHandle_t, reader: *mut GEOSWKBReader);
}
extern "C" {
    #[doc = " \\see GEOSWKBReader_read"]
    pub fn GEOSWKBReader_read_r(
        handle: GEOSContextHandle_t,
        reader: *mut GEOSWKBReader,
        wkb: *const libc::c_uchar,
        size: usize,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSWKBReader_readHEX"]
    pub fn GEOSWKBReader_readHEX_r(
        handle: GEOSContextHandle_t,
        reader: *mut GEOSWKBReader,
        hex: *const libc::c_uchar,
        size: usize,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSWKBWriter_create"]
    pub fn GEOSWKBWriter_create_r(handle: GEOSContextHandle_t) -> *mut GEOSWKBWriter;
}
extern "C" {
    #[doc = " \\see GEOSWKBWriter_destroy"]
    pub fn GEOSWKBWriter_destroy_r(handle: GEOSContextHandle_t, writer: *mut GEOSWKBWriter);
}
extern "C" {
    #[doc = " \\see GEOSWKBWriter_write"]
    pub fn GEOSWKBWriter_write_r(
        handle: GEOSContextHandle_t,
        writer: *mut GEOSWKBWriter,
        g: *const GEOSGeometry,
        size: *mut usize,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    #[doc = " \\see GEOSWKBWriter_writeHEX"]
    pub fn GEOSWKBWriter_writeHEX_r(
        handle: GEOSContextHandle_t,
        writer: *mut GEOSWKBWriter,
        g: *const GEOSGeometry,
        size: *mut usize,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    #[doc = " \\see GEOSWKBWriter_getOutputDimension"]
    pub fn GEOSWKBWriter_getOutputDimension_r(
        handle: GEOSContextHandle_t,
        writer: *const GEOSWKBWriter,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSWKBWriter_setOutputDimension"]
    pub fn GEOSWKBWriter_setOutputDimension_r(
        handle: GEOSContextHandle_t,
        writer: *mut GEOSWKBWriter,
        newDimension: libc::c_int,
    );
}
extern "C" {
    #[doc = " \\see GEOSWKBWriter_getByteOrder"]
    pub fn GEOSWKBWriter_getByteOrder_r(
        handle: GEOSContextHandle_t,
        writer: *const GEOSWKBWriter,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSWKBWriter_setByteOrder"]
    pub fn GEOSWKBWriter_setByteOrder_r(
        handle: GEOSContextHandle_t,
        writer: *mut GEOSWKBWriter,
        byteOrder: libc::c_int,
    );
}
extern "C" {
    #[doc = " \\see GEOSWKBWriter_getFlavor"]
    pub fn GEOSWKBWriter_getFlavor_r(
        handle: GEOSContextHandle_t,
        writer: *const GEOSWKBWriter,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\see GEOSWKBWriter_setFlavor"]
    pub fn GEOSWKBWriter_setFlavor_r(
        handle: GEOSContextHandle_t,
        writer: *mut GEOSWKBWriter,
        flavor: libc::c_int,
    );
}
extern "C" {
    #[doc = " \\see GEOSWKBWriter_getIncludeSRID"]
    pub fn GEOSWKBWriter_getIncludeSRID_r(
        handle: GEOSContextHandle_t,
        writer: *const GEOSWKBWriter,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSWKBWriter_setIncludeSRID"]
    pub fn GEOSWKBWriter_setIncludeSRID_r(
        handle: GEOSContextHandle_t,
        writer: *mut GEOSWKBWriter,
        writeSRID: libc::c_char,
    );
}
extern "C" {
    #[doc = " \\see GEOSGeoJSONReader_create"]
    pub fn GEOSGeoJSONReader_create_r(handle: GEOSContextHandle_t) -> *mut GEOSGeoJSONReader;
}
extern "C" {
    #[doc = " \\see GEOSGeoJSONReader_destroy"]
    pub fn GEOSGeoJSONReader_destroy_r(handle: GEOSContextHandle_t, reader: *mut GEOSGeoJSONReader);
}
extern "C" {
    #[doc = " \\see GEOSWKTReader_read"]
    pub fn GEOSGeoJSONReader_readGeometry_r(
        handle: GEOSContextHandle_t,
        reader: *mut GEOSGeoJSONReader,
        geojson: *const libc::c_char,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\see GEOSGeoJSONWriter_create"]
    pub fn GEOSGeoJSONWriter_create_r(handle: GEOSContextHandle_t) -> *mut GEOSGeoJSONWriter;
}
extern "C" {
    #[doc = " \\see GEOSGeoJSONWriter_destroy"]
    pub fn GEOSGeoJSONWriter_destroy_r(handle: GEOSContextHandle_t, writer: *mut GEOSGeoJSONWriter);
}
extern "C" {
    #[doc = " \\see GEOSGeoJSONWriter_writeGeometry"]
    pub fn GEOSGeoJSONWriter_writeGeometry_r(
        handle: GEOSContextHandle_t,
        writer: *mut GEOSGeoJSONWriter,
        g: *const GEOSGeometry,
        indent: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " \\see GEOSFree"]
    pub fn GEOSFree_r(handle: GEOSContextHandle_t, buffer: *mut libc::c_void);
}
extern "C" {
    #[doc = " Returns the current GEOS version string. eg: \"3.10.0\""]
    #[doc = " This function does not have a reentrant variant and is"]
    #[doc = " available if `GEOS_USE_ONLY_R_API` is defined."]
    #[doc = " \\return version string"]
    pub fn GEOSversion() -> *const libc::c_char;
}
extern "C" {
    #[doc = " For non-reentrant code, set up an execution contact, and associate"]
    #[doc = " \\ref GEOSMessageHandler functions with it, to pass error and notice"]
    #[doc = " messages back to the calling application."]
    #[doc = " <pre>"]
    #[doc = " typedef void (*GEOSMessageHandler)(const char *fmt, ...);"]
    #[doc = " </pre>"]
    #[doc = ""]
    #[doc = " \\param notice_function Handle notice messages"]
    #[doc = " \\param error_function Handle error messages"]
    pub fn initGEOS(notice_function: GEOSMessageHandler, error_function: GEOSMessageHandler);
}
extern "C" {
    #[doc = " For non-reentrant code, call when all GEOS operations are complete,"]
    #[doc = " cleans up global resources."]
    pub fn finishGEOS();
}
extern "C" {
    #[doc = " Free strings and byte buffers returned by functions such"]
    #[doc = " as GEOSWKBWriter_write(),"]
    #[doc = " GEOSWKBWriter_writeHEX() and GEOSWKTWriter_write(), etc."]
    #[doc = " \\param buffer The memory to free"]
    pub fn GEOSFree(buffer: *mut libc::c_void);
}
extern "C" {
    #[doc = " Create a coordinate sequence."]
    #[doc = " \\param size number of coordinates in the sequence"]
    #[doc = " \\param dims dimensionality of the coordinates (2 or 3)"]
    #[doc = " \\return the sequence or NULL on exception"]
    pub fn GEOSCoordSeq_create(size: libc::c_uint, dims: libc::c_uint) -> *mut GEOSCoordSequence;
}
extern "C" {
    #[doc = " Create a coordinate sequence by copying from a buffer of doubles (XYXY or XYZXYZ)"]
    #[doc = " \\param buf pointer to buffer"]
    #[doc = " \\param size number of coordinates in the sequence"]
    #[doc = " \\param hasZ does buffer have Z values?"]
    #[doc = " \\param hasM does buffer have M values? (they will be ignored)"]
    #[doc = " \\return the sequence or NULL on exception"]
    pub fn GEOSCoordSeq_copyFromBuffer(
        buf: *const f64,
        size: libc::c_uint,
        hasZ: libc::c_int,
        hasM: libc::c_int,
    ) -> *mut GEOSCoordSequence;
}
extern "C" {
    #[doc = " Create a coordinate sequence by copying from arrays of doubles"]
    #[doc = " \\param x array of x coordinates"]
    #[doc = " \\param y array of y coordinates"]
    #[doc = " \\param z array of z coordinates, or NULL"]
    #[doc = " \\param m array of m coordinates, (must be NULL)"]
    #[doc = " \\param size length of each array"]
    #[doc = " \\return the sequence or NULL on exception"]
    pub fn GEOSCoordSeq_copyFromArrays(
        x: *const f64,
        y: *const f64,
        z: *const f64,
        m: *const f64,
        size: libc::c_uint,
    ) -> *mut GEOSCoordSequence;
}
extern "C" {
    #[doc = " Copy the contents of a coordinate sequence to a buffer of doubles (XYXY or XYZXYZ)"]
    #[doc = " \\param s sequence to copy"]
    #[doc = " \\param buf buffer to which coordinates should be copied"]
    #[doc = " \\param hasZ copy Z values to buffer?"]
    #[doc = " \\param hasM copy M values to buffer? (will be NaN)"]
    #[doc = " \\return 1 on success, 0 on error"]
    pub fn GEOSCoordSeq_copyToBuffer(
        s: *const GEOSCoordSequence,
        buf: *mut f64,
        hasZ: libc::c_int,
        hasM: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Copy the contents of a coordinate sequence to a buffer of doubles (XYZY or XYZXYZ)"]
    #[doc = " \\param s sequence to copy"]
    #[doc = " \\param x array to which x values should be copied"]
    #[doc = " \\param y array to which y values should be copied"]
    #[doc = " \\param z array to which z values should be copied, or NULL"]
    #[doc = " \\param m array to which m values should be copied (will all be NAN)"]
    #[doc = " \\return 1 on success, 0 on error"]
    pub fn GEOSCoordSeq_copyToArrays(
        s: *const GEOSCoordSequence,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
        m: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Clone a coordinate sequence."]
    #[doc = " \\param s the coordinate sequence to clone"]
    #[doc = " \\return a copy of the coordinate sequence or NULL on exception"]
    pub fn GEOSCoordSeq_clone(s: *const GEOSCoordSequence) -> *mut GEOSCoordSequence;
}
extern "C" {
    #[doc = " Destroy a coordinate sequence, freeing all memory."]
    #[doc = " \\param s the coordinate sequence to destroy"]
    pub fn GEOSCoordSeq_destroy(s: *mut GEOSCoordSequence);
}
extern "C" {
    #[doc = " Set X ordinate values in a coordinate sequence."]
    #[doc = " \\param s the coordinate sequence"]
    #[doc = " \\param idx the index of the coordinate to alter, zero based"]
    #[doc = " \\param val the value to set the ordinate to"]
    #[doc = " \\return 0 on exception"]
    pub fn GEOSCoordSeq_setX(s: *mut GEOSCoordSequence, idx: libc::c_uint, val: f64)
        -> libc::c_int;
}
extern "C" {
    #[doc = " Set Y ordinate values in a coordinate sequence."]
    #[doc = " \\param s the coordinate sequence"]
    #[doc = " \\param idx the index of the coordinate to alter, zero based"]
    #[doc = " \\param val the value to set the ordinate to"]
    #[doc = " \\return 0 on exception"]
    pub fn GEOSCoordSeq_setY(s: *mut GEOSCoordSequence, idx: libc::c_uint, val: f64)
        -> libc::c_int;
}
extern "C" {
    #[doc = " Set Z ordinate values in a coordinate sequence."]
    #[doc = " \\param s the coordinate sequence"]
    #[doc = " \\param idx the index of the coordinate to alter, zero based"]
    #[doc = " \\param val the value to set the ordinate to"]
    #[doc = " \\return 0 on exception"]
    pub fn GEOSCoordSeq_setZ(s: *mut GEOSCoordSequence, idx: libc::c_uint, val: f64)
        -> libc::c_int;
}
extern "C" {
    #[doc = " Set X and Y ordinate values in a coordinate sequence simultaneously."]
    #[doc = " \\param s the coordinate sequence"]
    #[doc = " \\param idx the index of the coordinate to alter, zero based"]
    #[doc = " \\param x the value to set the X ordinate to"]
    #[doc = " \\param y the value to set the Y ordinate to"]
    #[doc = " \\return 0 on exception"]
    pub fn GEOSCoordSeq_setXY(
        s: *mut GEOSCoordSequence,
        idx: libc::c_uint,
        x: f64,
        y: f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set X, Y and Z ordinate values in a coordinate sequence simultaneously."]
    #[doc = " \\param s the coordinate sequence"]
    #[doc = " \\param idx the index of the coordinate to alter, zero based"]
    #[doc = " \\param x the value to set the X ordinate to"]
    #[doc = " \\param y the value to set the Y ordinate to"]
    #[doc = " \\param z the value to set the Z ordinate to"]
    #[doc = " \\return 0 on exception"]
    pub fn GEOSCoordSeq_setXYZ(
        s: *mut GEOSCoordSequence,
        idx: libc::c_uint,
        x: f64,
        y: f64,
        z: f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set Nth ordinate value in a coordinate sequence."]
    #[doc = " \\param s the coordinate sequence"]
    #[doc = " \\param idx the index of the coordinate to alter, zero based"]
    #[doc = " \\param dim the dimension number of the ordinate to alter, zero based"]
    #[doc = " \\param val the value to set the ordinate to"]
    #[doc = " \\return 0 on exception"]
    pub fn GEOSCoordSeq_setOrdinate(
        s: *mut GEOSCoordSequence,
        idx: libc::c_uint,
        dim: libc::c_uint,
        val: f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Read X ordinate values from a coordinate sequence."]
    #[doc = " \\param s the coordinate sequence"]
    #[doc = " \\param idx the index of the coordinate to alter, zero based"]
    #[doc = " \\param val pointer where ordinate value will be placed"]
    #[doc = " \\return 0 on exception"]
    pub fn GEOSCoordSeq_getX(
        s: *const GEOSCoordSequence,
        idx: libc::c_uint,
        val: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Read Y ordinate values from a coordinate sequence."]
    #[doc = " \\param s the coordinate sequence"]
    #[doc = " \\param idx the index of the coordinate to alter, zero based"]
    #[doc = " \\param val pointer where ordinate value will be placed"]
    #[doc = " \\return 0 on exception"]
    pub fn GEOSCoordSeq_getY(
        s: *const GEOSCoordSequence,
        idx: libc::c_uint,
        val: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Read Z ordinate values from a coordinate sequence."]
    #[doc = " \\param s the coordinate sequence"]
    #[doc = " \\param idx the index of the coordinate to alter, zero based"]
    #[doc = " \\param val pointer where ordinate value will be placed"]
    #[doc = " \\return 0 on exception"]
    pub fn GEOSCoordSeq_getZ(
        s: *const GEOSCoordSequence,
        idx: libc::c_uint,
        val: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Read X and Y ordinate values from a coordinate sequence."]
    #[doc = " \\param s the coordinate sequence"]
    #[doc = " \\param idx the index of the coordinate to alter, zero based"]
    #[doc = " \\param x pointer where ordinate X value will be placed"]
    #[doc = " \\param y pointer where ordinate Y value will be placed"]
    #[doc = " \\return 0 on exception"]
    pub fn GEOSCoordSeq_getXY(
        s: *const GEOSCoordSequence,
        idx: libc::c_uint,
        x: *mut f64,
        y: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Read X and Y ordinate values from a coordinate sequence."]
    #[doc = " \\param s the coordinate sequence"]
    #[doc = " \\param idx the index of the coordinate to alter, zero based"]
    #[doc = " \\param x pointer where ordinate X value will be placed"]
    #[doc = " \\param y pointer where ordinate Y value will be placed"]
    #[doc = " \\param z pointer where ordinate Z value will be placed"]
    #[doc = " \\return 0 on exception"]
    pub fn GEOSCoordSeq_getXYZ(
        s: *const GEOSCoordSequence,
        idx: libc::c_uint,
        x: *mut f64,
        y: *mut f64,
        z: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Read Nth ordinate value from a coordinate sequence."]
    #[doc = " \\param[in] s the coordinate sequence"]
    #[doc = " \\param[in] idx the index of the coordinate to alter, zero based"]
    #[doc = " \\param[in] dim the dimension number of the ordinate to read, zero based"]
    #[doc = " \\param[out] val pointer where ordinate value will be placed"]
    #[doc = " \\return 0 on exception"]
    pub fn GEOSCoordSeq_getOrdinate(
        s: *const GEOSCoordSequence,
        idx: libc::c_uint,
        dim: libc::c_uint,
        val: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get size info from a coordinate sequence."]
    #[doc = " \\param[in] s the coordinate sequence"]
    #[doc = " \\param[out] size pointer where size value will be placed"]
    #[doc = " \\return 0 on exception"]
    pub fn GEOSCoordSeq_getSize(
        s: *const GEOSCoordSequence,
        size: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get dimension info from a coordinate sequence."]
    #[doc = " \\param[in] s the coordinate sequence"]
    #[doc = " \\param[out] dims pointer where dimension value will be placed"]
    #[doc = " \\return 0 on exception"]
    pub fn GEOSCoordSeq_getDimensions(
        s: *const GEOSCoordSequence,
        dims: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Check orientation of a coordinate sequence. Closure of the sequence is"]
    #[doc = " assumed. Invalid (collapsed) sequences will return false. Short (less"]
    #[doc = " than 4 points) sequences will return exception."]
    #[doc = " \\param s the coordinate sequence"]
    #[doc = " \\param is_ccw pointer for ccw value, 1 if counter-clockwise orientation, 0 otherwise"]
    #[doc = " \\return 0 on exception, 1 on success"]
    pub fn GEOSCoordSeq_isCCW(
        s: *const GEOSCoordSequence,
        is_ccw: *mut libc::c_char,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Creates a point geometry from a coordinate sequence."]
    #[doc = " \\param s Input coordinate sequence, ownership passes to the geometry"]
    #[doc = " \\return A newly allocated point geometry. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    pub fn GEOSGeom_createPoint(s: *mut GEOSCoordSequence) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Creates a point geometry from a pair of coordinates."]
    #[doc = " \\param x The X coordinate"]
    #[doc = " \\param y The Y coordinate"]
    #[doc = " \\return A newly allocated point geometry. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    pub fn GEOSGeom_createPointFromXY(x: f64, y: f64) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Creates an empty point."]
    #[doc = " \\return A newly allocated empty point geometry. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    pub fn GEOSGeom_createEmptyPoint() -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Creates a linear ring geometry, for use in a polygon."]
    #[doc = " \\param s Input coordinate sequence, ownership passes to the geometry"]
    #[doc = " \\return A newly allocated linear ring geometry. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    pub fn GEOSGeom_createLinearRing(s: *mut GEOSCoordSequence) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Creates a linestring geometry."]
    #[doc = " \\param s Input coordinate sequence, ownership passes to the geometry"]
    #[doc = " \\return A newly allocated linestring geometry. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    pub fn GEOSGeom_createLineString(s: *mut GEOSCoordSequence) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Creates an emptylinestring geometry."]
    #[doc = " \\return A newly allocated linestring geometry. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    pub fn GEOSGeom_createEmptyLineString() -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Creates an empty polygon geometry."]
    #[doc = " \\return A newly allocated empty polygon geometry. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    pub fn GEOSGeom_createEmptyPolygon() -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Creates a polygon geometry from line ring geometries."]
    #[doc = " \\param shell A linear ring that is the exterior ring of the polygon."]
    #[doc = " \\param holes An array of linear rings that are the holes."]
    #[doc = " \\param nholes The number of rings in the holes array."]
    #[doc = " \\return A newly allocated geometry. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\note The holes argument is an array of GEOSGeometry* objects."]
    #[doc = "       The caller **retains ownership** of the containing array,"]
    #[doc = "       but the ownership of the pointed-to objects is transferred"]
    #[doc = "       to the returned \\ref GEOSGeometry."]
    pub fn GEOSGeom_createPolygon(
        shell: *mut GEOSGeometry,
        holes: *mut *mut GEOSGeometry,
        nholes: libc::c_uint,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Create a geometry collection."]
    #[doc = " \\param type The geometry type, enumerated by \\ref GEOSGeomTypes"]
    #[doc = " \\param geoms A list of geometries that will form the collection"]
    #[doc = " \\param ngeoms The number of geometries in the geoms list"]
    #[doc = " \\return A newly allocated geometry collection. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\note The holes argument is an array of GEOSGeometry* objects."]
    #[doc = "       The caller **retains ownership** of the containing array,"]
    #[doc = "       but the ownership of the pointed-to objects is transferred"]
    #[doc = "       to the returned \\ref GEOSGeometry."]
    pub fn GEOSGeom_createCollection(
        type_: libc::c_int,
        geoms: *mut *mut GEOSGeometry,
        ngeoms: libc::c_uint,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Create an empty geometry collection."]
    #[doc = " \\param type The geometry type, enumerated by \\ref GEOSGeomTypes"]
    #[doc = " \\return A newly allocated empty geometry collection. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    pub fn GEOSGeom_createEmptyCollection(type_: libc::c_int) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Create a rectangular polygon from bounding coordinates."]
    #[doc = " Will return a point geometry if width and height are 0."]
    #[doc = " \\param xmin Left bound of envelope"]
    #[doc = " \\param ymin Lower bound of envelope"]
    #[doc = " \\param xmax Right bound of envelope"]
    #[doc = " \\param ymax Upper bound of envelope"]
    pub fn GEOSGeom_createRectangle(
        xmin: f64,
        ymin: f64,
        xmax: f64,
        ymax: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Create a new copy of the input geometry."]
    #[doc = " \\param g The geometry to copy"]
    #[doc = " \\return A newly allocated geometry. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    pub fn GEOSGeom_clone(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Release the memory associated with a geometry."]
    #[doc = " \\param g The geometry to be destroyed."]
    pub fn GEOSGeom_destroy(g: *mut GEOSGeometry);
}
extern "C" {
    #[doc = " Returns the geometry type string for this geometry."]
    #[doc = " eg: \"GeometryCollection\", \"LineString\""]
    #[doc = " \\param g Input geometry"]
    #[doc = " \\return A string with the geometry type."]
    #[doc = " Caller must free with GEOSFree()."]
    #[doc = " NULL on exception."]
    pub fn GEOSGeomType(g: *const GEOSGeometry) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Returns the \\ref GEOSGeomTypeId number for this geometry."]
    #[doc = " \\param g Input geometry"]
    #[doc = " \\return The geometry type number, or -1 on exception."]
    pub fn GEOSGeomTypeId(g: *const GEOSGeometry) -> libc::c_int;
}
extern "C" {
    #[doc = " Returns the \"spatial reference id\" (SRID) for this geometry."]
    #[doc = " \\param g Input geometry"]
    #[doc = " \\return SRID number or 0 if unknown / not set."]
    pub fn GEOSGetSRID(g: *const GEOSGeometry) -> libc::c_int;
}
extern "C" {
    #[doc = " Return the anonymous \"user data\" for this geometry."]
    #[doc = " User data must be managed by the caller, and freed before"]
    #[doc = " the geometry is freed."]
    #[doc = " \\param g Input geometry"]
    #[doc = " \\return A void* to the user data, caller is responsible for"]
    #[doc = "         casting to the appropriate type and freeing."]
    pub fn GEOSGeom_getUserData(g: *const GEOSGeometry) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " Returns the number of sub-geometries immediately under a"]
    #[doc = " multi-geometry or collection or 1 for a simple geometry."]
    #[doc = " For nested collections, remember to check if returned"]
    #[doc = " sub-geometries are **themselves** also collections."]
    #[doc = " \\param g Input geometry"]
    #[doc = " \\return Number of direct children in this collection"]
    #[doc = " \\warning For GEOS < 3.2 this function may crash when fed simple geometries"]
    pub fn GEOSGetNumGeometries(g: *const GEOSGeometry) -> libc::c_int;
}
extern "C" {
    #[doc = " Returns the specified sub-geometry of a collection. For"]
    #[doc = " a simple geometry, returns a pointer to the input."]
    #[doc = " Returned object is a pointer to internal storage:"]
    #[doc = " it must NOT be destroyed directly."]
    #[doc = " \\param g Input geometry"]
    #[doc = " \\param n Sub-geometry index, zero-base"]
    #[doc = " \\return A const \\ref GEOSGeometry, do not free!"]
    #[doc = "It will be freed when the parent is freed."]
    #[doc = "Returns NULL on exception."]
    #[doc = " \\note Up to GEOS 3.2.0 the input geometry must be a Collection, in"]
    #[doc = "       later versions it doesn't matter (getGeometryN(0) for a single will"]
    #[doc = "       return the input)."]
    pub fn GEOSGetGeometryN(g: *const GEOSGeometry, n: libc::c_int) -> *const GEOSGeometry;
}
extern "C" {
    #[doc = " Read the currently set precision value from the"]
    #[doc = " geometry and returns the grid size if it is a fixed"]
    #[doc = " precision or 0.0 if it is full floating point precision."]
    #[doc = " \\param g Input geometry"]
    #[doc = " \\return The grid size, or -1 on exception"]
    pub fn GEOSGeom_getPrecision(g: *const GEOSGeometry) -> f64;
}
extern "C" {
    #[doc = " Returns the number of interior rings, for a Polygon input, or"]
    #[doc = " an exception otherwise."]
    #[doc = " \\param g Input Polygon geometry"]
    #[doc = " \\return Number of interior rings, -1 on exception"]
    pub fn GEOSGetNumInteriorRings(g: *const GEOSGeometry) -> libc::c_int;
}
extern "C" {
    #[doc = " Returns the number of points, for a LineString input, or"]
    #[doc = " an exception otherwise."]
    #[doc = " \\param g Input LineString geometry"]
    #[doc = " \\return Number of points, -1 on exception"]
    pub fn GEOSGeomGetNumPoints(g: *const GEOSGeometry) -> libc::c_int;
}
extern "C" {
    #[doc = " Returns the X coordinate, for a Point input, or an"]
    #[doc = " exception otherwise."]
    #[doc = " \\param[in] g Input Point geometry"]
    #[doc = " \\param[out] x Pointer to hold return value"]
    #[doc = " \\returns 1 on success, 0 on exception"]
    pub fn GEOSGeomGetX(g: *const GEOSGeometry, x: *mut f64) -> libc::c_int;
}
extern "C" {
    #[doc = " Returns the Y coordinate, for a Point input, or an"]
    #[doc = " exception otherwise."]
    #[doc = " \\param[in] g Input Point geometry"]
    #[doc = " \\param[out] y Pointer to hold return value"]
    #[doc = " \\returns 1 on success, 0 on exception"]
    pub fn GEOSGeomGetY(g: *const GEOSGeometry, y: *mut f64) -> libc::c_int;
}
extern "C" {
    #[doc = " Returns the Z coordinate, for a Point input, or an"]
    #[doc = " exception otherwise."]
    #[doc = " \\param[in] g Input Point geometry"]
    #[doc = " \\param[out] z Pointer to hold return value"]
    #[doc = " \\returns 1 on success, 0 on exception"]
    pub fn GEOSGeomGetZ(g: *const GEOSGeometry, z: *mut f64) -> libc::c_int;
}
extern "C" {
    #[doc = " Returns the N'th ring for a Polygon input."]
    #[doc = " \\note Returned object is a pointer to internal storage:"]
    #[doc = "       it must NOT be destroyed directly."]
    #[doc = " \\param g Input Polygon geometry"]
    #[doc = " \\param n Index of the desired ring"]
    #[doc = " \\return LinearRing geometry. Owned by parent geometry, do not free. NULL on exception."]
    pub fn GEOSGetInteriorRingN(g: *const GEOSGeometry, n: libc::c_int) -> *const GEOSGeometry;
}
extern "C" {
    #[doc = " Get the external ring of a Polygon."]
    #[doc = " \\note Returned object is a pointer to internal storage:"]
    #[doc = "       it must NOT be destroyed directly."]
    #[doc = " \\param g Input Polygon geometry"]
    #[doc = " \\return LinearRing geometry. Owned by parent geometry, do not free. NULL on exception."]
    pub fn GEOSGetExteriorRing(g: *const GEOSGeometry) -> *const GEOSGeometry;
}
extern "C" {
    #[doc = " Get the total number of points in a geometry,"]
    #[doc = " of any type."]
    #[doc = " \\param g Input geometry"]
    #[doc = " \\return Number of points in the geometry. -1 on exception."]
    pub fn GEOSGetNumCoordinates(g: *const GEOSGeometry) -> libc::c_int;
}
extern "C" {
    #[doc = " Return the coordinate sequence underlying the"]
    #[doc = " given geometry (Must be a LineString, LinearRing or Point)."]
    #[doc = " Do not directly free the coordinate sequence, it is owned by"]
    #[doc = " the parent geometry."]
    #[doc = " \\param g Input geometry"]
    #[doc = " \\return Coordinate sequence or NULL on exception."]
    pub fn GEOSGeom_getCoordSeq(g: *const GEOSGeometry) -> *const GEOSCoordSequence;
}
extern "C" {
    #[doc = " Return the planar dimensionality of the geometry."]
    #[doc = ""]
    #[doc = " - 0 for point, multipoint"]
    #[doc = " - 1 for linestring, multilinestring"]
    #[doc = " - 2 for polygon, multipolygon"]
    #[doc = ""]
    #[doc = " \\see geos::geom::Dimension::DimensionType"]
    #[doc = " \\param g Input geometry"]
    #[doc = " \\return The dimensionality"]
    pub fn GEOSGeom_getDimensions(g: *const GEOSGeometry) -> libc::c_int;
}
extern "C" {
    #[doc = " Return the cartesian dimension of the geometry."]
    #[doc = ""]
    #[doc = " - 2 for XY data"]
    #[doc = " - 3 for XYZ data"]
    #[doc = ""]
    #[doc = " \\param g Input geometry"]
    #[doc = " \\return The dimension"]
    pub fn GEOSGeom_getCoordinateDimension(g: *const GEOSGeometry) -> libc::c_int;
}
extern "C" {
    #[doc = " Finds the minimum X value in the geometry."]
    #[doc = " \\param[in] g Input geometry"]
    #[doc = " \\param[out] value Pointer to place result"]
    #[doc = " \\return 0 on exception"]
    pub fn GEOSGeom_getXMin(g: *const GEOSGeometry, value: *mut f64) -> libc::c_int;
}
extern "C" {
    #[doc = " Finds the minimum Y value in the geometry."]
    #[doc = " \\param[in] g Input geometry"]
    #[doc = " \\param[out] value Pointer to place result"]
    #[doc = " \\return 0 on exception"]
    pub fn GEOSGeom_getYMin(g: *const GEOSGeometry, value: *mut f64) -> libc::c_int;
}
extern "C" {
    #[doc = " Finds the maximum X value in the geometry."]
    #[doc = " \\param[in] g Input geometry"]
    #[doc = " \\param[out] value Pointer to place result"]
    #[doc = " \\return 0 on exception"]
    pub fn GEOSGeom_getXMax(g: *const GEOSGeometry, value: *mut f64) -> libc::c_int;
}
extern "C" {
    #[doc = " Finds the maximum Y value in the geometry."]
    #[doc = " \\param[in] g Input geometry"]
    #[doc = " \\param[out] value Pointer to place result"]
    #[doc = " \\return 0 on exception"]
    pub fn GEOSGeom_getYMax(g: *const GEOSGeometry, value: *mut f64) -> libc::c_int;
}
extern "C" {
    #[doc = " Finds the extent (minimum and maximum X and Y value) of the geometry."]
    #[doc = " Raises an exception for empty geometry input."]
    #[doc = ""]
    #[doc = " \\param[in] g Input geometry"]
    #[doc = " \\param[out] xmin Pointer to place result for minimum X value"]
    #[doc = " \\param[out] ymin Pointer to place result for minimum Y value"]
    #[doc = " \\param[out] xmax Pointer to place result for maximum X value"]
    #[doc = " \\param[out] ymax Pointer to place result for maximum Y value"]
    #[doc = " \\return 1 on success, 0 on exception"]
    pub fn GEOSGeom_getExtent(
        g: *const GEOSGeometry,
        xmin: *mut f64,
        ymin: *mut f64,
        xmax: *mut f64,
        ymax: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Return the N'th point of a LineString"]
    #[doc = " \\param g Input geometry, must be a LineString"]
    #[doc = " \\param n Index of desired point (zero based)"]
    #[doc = " \\return A Point geometry."]
    #[doc = "         Caller must free with GEOSGeom_destroy()"]
    #[doc = "         NULL on exception."]
    pub fn GEOSGeomGetPointN(g: *const GEOSGeometry, n: libc::c_int) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Return the first point of a LineString"]
    #[doc = " \\param g Input geometry, must be a LineString"]
    #[doc = " \\return A Point geometry."]
    #[doc = "         Caller must free with GEOSGeom_destroy()"]
    #[doc = "         NULL on exception."]
    pub fn GEOSGeomGetStartPoint(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Return the last point of a LineString"]
    #[doc = " \\param g Input geometry, must be a LineString"]
    #[doc = " \\return A Point geometry."]
    #[doc = "         Caller must free with GEOSGeom_destroy()"]
    #[doc = "         NULL on exception."]
    pub fn GEOSGeomGetEndPoint(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Tests whether the input geometry is empty. If the geometry or any"]
    #[doc = " component is non-empty, the geometry is non-empty. An empty geometry"]
    #[doc = " has no boundary or interior."]
    #[doc = " \\param g The geometry to test"]
    #[doc = " \\return 1 on true, 0 on false, 2 on exception"]
    pub fn GEOSisEmpty(g: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    #[doc = " Tests whether the input geometry is a ring. Rings are"]
    #[doc = " linestrings, without self-intersections,"]
    #[doc = " with start and end point being identical."]
    #[doc = " \\param g The geometry to test"]
    #[doc = " \\return 1 on true, 0 on false, 2 on exception"]
    pub fn GEOSisRing(g: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    #[doc = " Tests whether the input geometry has z coordinates."]
    #[doc = " \\param g The geometry to test"]
    #[doc = " \\return 1 on true, 0 on false, 2 on exception"]
    pub fn GEOSHasZ(g: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    #[doc = " Tests whether the input geometry is closed."]
    #[doc = " A closed geometry is a linestring or multilinestring"]
    #[doc = " with the start and end points being the same."]
    #[doc = " \\param g The geometry to test"]
    #[doc = " \\return 1 on true, 0 on false, 2 on exception"]
    pub fn GEOSisClosed(g: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    #[doc = " Set the \"spatial reference id\" (SRID) for this geometry."]
    #[doc = " \\param g Input geometry"]
    #[doc = " \\param SRID SRID number or 0 for unknown SRID."]
    pub fn GEOSSetSRID(g: *mut GEOSGeometry, SRID: libc::c_int);
}
extern "C" {
    #[doc = " Set the anonymous \"user data\" for this geometry."]
    #[doc = " Don't forget to free the user data before freeing the geometry."]
    #[doc = " \\param g Input geometry"]
    #[doc = " \\param userData Void pointer to user data"]
    pub fn GEOSGeom_setUserData(g: *mut GEOSGeometry, userData: *mut libc::c_void);
}
extern "C" {
    #[doc = " Organize the elements, rings, and coordinate order"]
    #[doc = " of geometries in a consistent way,"]
    #[doc = " so that geometries that represent the same"]
    #[doc = " object can be easily compared."]
    #[doc = " Modifies the geometry in-place."]
    #[doc = ""]
    #[doc = " Normalization ensures the following:"]
    #[doc = " - Lines are oriented to have smallest coordinate first (apart from duplicate endpoints)"]
    #[doc = " - Rings start with their smallest coordinate"]
    #[doc = "   (using XY ordering)"]
    #[doc = " - Polygon shell rings are oriented CW, and holes CCW"]
    #[doc = " - Collection elements are sorted by their first coordinate"]
    #[doc = ""]
    #[doc = " Use before calling \\ref GEOSEqualsExact to avoid false \"not equal\" results."]
    #[doc = " \\param g Input geometry"]
    #[doc = " \\return 0 on success or -1 on exception"]
    pub fn GEOSNormalize(g: *mut GEOSGeometry) -> libc::c_int;
}
extern "C" {
    #[doc = " Tests whether the input geometry is \"simple\". Mostly relevant for"]
    #[doc = " linestrings. A \"simple\" linestring has no self-intersections."]
    #[doc = " \\param g The geometry to test"]
    #[doc = " \\return 1 on true, 0 on false, 2 on exception"]
    pub fn GEOSisSimple(g: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    #[doc = " Check the validity of the provided geometry."]
    #[doc = " - All points are valid."]
    #[doc = " - All non-zero-length linestrings are valid."]
    #[doc = " - Polygon rings must be non-self-intersecting, and interior rings"]
    #[doc = "   contained within exterior rings."]
    #[doc = " - Multi-polygon components may not touch or overlap."]
    #[doc = ""]
    #[doc = " \\param g The geometry to test"]
    #[doc = " \\return 1 on true, 0 on false, 2 on exception"]
    #[doc = " \\see geos::operation::valid::isValidOp"]
    pub fn GEOSisValid(g: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    #[doc = " Return the human readable reason a geometry is invalid,"]
    #[doc = " \"Valid Geometry\" string otherwise, or NULL on exception."]
    #[doc = " \\param g The geometry to test"]
    #[doc = " \\return A string with the reason, NULL on exception."]
    #[doc = "Caller must GEOSFree() their result."]
    pub fn GEOSisValidReason(g: *const GEOSGeometry) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " In one step, calculate and return the validity, the"]
    #[doc = " human readable validity reason and a point at which validity"]
    #[doc = " rules are broken."]
    #[doc = " Caller has the responsibility to destroy 'reason' with GEOSFree()"]
    #[doc = " and 'location' with GEOSGeom_destroy()"]
    #[doc = " \\param g The geometry to test"]
    #[doc = " \\param flags A value from the \\ref GEOSValidFlags enum"]
    #[doc = " \\param reason A pointer in which the reason string will be places"]
    #[doc = " \\param location A pointer in which the location GEOSGeometry will be placed"]
    #[doc = " \\return 1 when valid, 0 when invalid, 2 on exception"]
    pub fn GEOSisValidDetail(
        g: *const GEOSGeometry,
        flags: libc::c_int,
        reason: *mut *mut libc::c_char,
        location: *mut *mut GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " Repair an invalid geometry, returning a valid output."]
    #[doc = " \\param g The geometry to repair"]
    #[doc = " \\return The repaired geometry. Caller must free with GEOSGeom_destroy()."]
    pub fn GEOSMakeValid(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Repair an invalid geometry, returning a valid output, using the"]
    #[doc = " indicated GEOSMakeValidMethods algorithm and options."]
    #[doc = " \\param g is the geometry to test."]
    #[doc = " \\param makeValidParams is a GEOSMakeValidParams with the desired parameters set on it."]
    #[doc = " \\return A repaired geometry. Caller must free with GEOSGeom_destroy()."]
    #[doc = " \\see GEOSMakeValidParams_create"]
    #[doc = " \\see GEOSMakeValidParams_destroy"]
    #[doc = " \\see GEOSMakeValidParams_setMethod"]
    #[doc = " \\see GEOSMakeValidParams_setKeepCollapsed"]
    pub fn GEOSMakeValidWithParams(
        g: *const GEOSGeometry,
        makeValidParams: *const GEOSMakeValidParams,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Create a GEOSMakeValidParams to hold the desired parameters"]
    #[doc = " to control the algorithm and behavior of the validation process."]
    #[doc = " \\return a parameter object"]
    #[doc = " \\see GEOSMakeValidWithParams"]
    pub fn GEOSMakeValidParams_create() -> *mut GEOSMakeValidParams;
}
extern "C" {
    #[doc = " Destroy a GEOSMakeValidParams."]
    #[doc = " \\param parms the object to destroy"]
    #[doc = " \\see GEOSMakeValidWithParams"]
    pub fn GEOSMakeValidParams_destroy(parms: *mut GEOSMakeValidParams);
}
extern "C" {
    #[doc = " Set the GEOSMakeValidMethods to use in making the geometry"]
    #[doc = " valid."]
    #[doc = " \\return 0 on exception, 1 on success."]
    #[doc = " \\see GEOSMakeValidWithParams"]
    pub fn GEOSMakeValidParams_setMethod(
        p: *mut GEOSMakeValidParams,
        method: GEOSMakeValidMethods,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " When this parameter is not set to 0, the GEOS_MAKE_VALID_STRUCTURE method will drop"]
    #[doc = " any component that has collapsed into a lower dimensionality."]
    #[doc = " For example, a ring collapsing to a line, or a line collapsing"]
    #[doc = " to a point."]
    #[doc = " \\return 0 on exception, 1 on success."]
    #[doc = " \\see GEOSMakeValidWithParams"]
    pub fn GEOSMakeValidParams_setKeepCollapsed(
        p: *mut GEOSMakeValidParams,
        keepCollapsed: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Computes the minimum clearance of a geometry.  The minimum clearance is the smallest amount by which"]
    #[doc = " a vertex could be move to produce an invalid polygon, a non-simple linestring, or a multipoint with"]
    #[doc = " repeated points.  If a geometry has a minimum clearance of 'eps', it can be said that:"]
    #[doc = ""]
    #[doc = " -  No two distinct vertices in the geometry are separated by less than 'eps'"]
    #[doc = " -  No vertex is closer than 'eps' to a line segment of which it is not an endpoint."]
    #[doc = ""]
    #[doc = " If the minimum clearance cannot be defined for a geometry (such as with a single point, or a multipoint"]
    #[doc = " whose points are identical, a value of Infinity will be calculated."]
    #[doc = ""]
    #[doc = " \\param g the input geometry"]
    #[doc = " \\param d a double to which the result can be stored"]
    #[doc = " \\return 0 if no exception occurred."]
    #[doc = "         2 if an exception occurred."]
    #[doc = " \\see geos::precision::MinimumClearance"]
    pub fn GEOSMinimumClearance(g: *const GEOSGeometry, d: *mut f64) -> libc::c_int;
}
extern "C" {
    #[doc = " Returns a LineString whose endpoints define the minimum clearance of a geometry."]
    #[doc = " If the geometry has no minimum clearance, an empty LineString will be returned."]
    #[doc = ""]
    #[doc = " \\param g the input geometry"]
    #[doc = " \\return a linestring geometry, or NULL if an exception occurred."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::precision::MinimumClearance"]
    pub fn GEOSMinimumClearanceLine(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Works from start of each coordinate sequence in the"]
    #[doc = " geometry, retaining points that are further away from the"]
    #[doc = " previous retained point than the tolerance value."]
    #[doc = ""]
    #[doc = " Removing repeated points with a non-zero tolerance may"]
    #[doc = " result in an invalid geometry being returned. Be sure"]
    #[doc = " to check and repair validity."]
    #[doc = ""]
    #[doc = " \\return A geometry with all points within the tolerance of each other removed."]
    #[doc = " \\param g The geometry to filter"]
    #[doc = " \\param tolerance Remove all points within this distance of each other. Use 0.0 to remove only exactly repeated points."]
    #[doc = ""]
    #[doc = " \\see GEOSMakeValidWithParams"]
    pub fn GEOSRemoveRepeatedPoints(g: *const GEOSGeometry, tolerance: f64) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Calculate the area of a geometry."]
    #[doc = " \\param[in] g Input geometry"]
    #[doc = " \\param[out] area Pointer to be filled in with area result"]
    #[doc = " \\return 1 on success, 0 on exception."]
    pub fn GEOSArea(g: *const GEOSGeometry, area: *mut f64) -> libc::c_int;
}
extern "C" {
    #[doc = " Calculate the length of a geometry."]
    #[doc = " \\param[in] g Input geometry"]
    #[doc = " \\param[out] length Pointer to be filled in with length result"]
    #[doc = " \\return 1 on success, 0 on exception."]
    pub fn GEOSLength(g: *const GEOSGeometry, length: *mut f64) -> libc::c_int;
}
extern "C" {
    #[doc = " Calculate the length of a LineString."]
    #[doc = " Only works for LineString inputs, returns exception otherwise."]
    #[doc = ""]
    #[doc = " \\param[in] g Input geometry"]
    #[doc = " \\param[out] length Pointer to be filled in with length result"]
    #[doc = " \\return 1 on success, 0 on exception."]
    pub fn GEOSGeomGetLength(g: *const GEOSGeometry, length: *mut f64) -> libc::c_int;
}
extern "C" {
    #[doc = " Calculate the distance between two geometries."]
    #[doc = " \\param[in] g1 Input geometry"]
    #[doc = " \\param[in] g2 Input geometry"]
    #[doc = " \\param[out] dist Pointer to be filled in with distance result"]
    #[doc = " \\return 1 on success, 0 on exception."]
    pub fn GEOSDistance(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Test whether the distance between two geometries is"]
    #[doc = " within the given dist."]
    #[doc = " \\param g1 Input geometry"]
    #[doc = " \\param g2 Input geometry"]
    #[doc = " \\param dist The max distance"]
    #[doc = " \\returns 1 on true, 0 on false, 2 on exception"]
    pub fn GEOSDistanceWithin(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        dist: f64,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " Calculate the distance between two geometries, using the"]
    #[doc = " indexed facet distance, which first indexes the geometries"]
    #[doc = " internally, then calculates the distance. Useful when one"]
    #[doc = " or both geometries is very large."]
    #[doc = " \\param[in] g1 Input geometry"]
    #[doc = " \\param[in] g2 Input geometry"]
    #[doc = " \\param[out] dist Pointer to be filled in with distance result"]
    #[doc = " \\return 1 on success, 0 on exception."]
    #[doc = " \\see geos::operation::distance:;IndexedFacetDistance"]
    pub fn GEOSDistanceIndexed(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " The closest points of the two geometries."]
    #[doc = " The first point comes from g1 geometry and the second point comes from g2."]
    #[doc = ""]
    #[doc = " \\param[in] g1 Input geometry"]
    #[doc = " \\param[in] g2 Input geometry"]
    #[doc = " \\return A coordinate sequence with the two points, or NULL on exception."]
    #[doc = " Caller must free with GEOSCoordSeq_destroy()."]
    pub fn GEOSNearestPoints(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
    ) -> *mut GEOSCoordSequence;
}
extern "C" {
    #[doc = " Calculate the Hausdorff distance between two geometries."]
    #[doc = " [Hausdorff distance](https://en.wikipedia.org/wiki/Hausdorff_distance)"]
    #[doc = " is the largest distance between two geometries."]
    #[doc = " \\param[in] g1 Input geometry"]
    #[doc = " \\param[in] g2 Input geometry"]
    #[doc = " \\param[out] dist Pointer to be filled in with distance result"]
    #[doc = " \\return 1 on success, 0 on exception."]
    #[doc = " \\see geos::algorithm::distance::DiscreteHausdorffDistance"]
    pub fn GEOSHausdorffDistance(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Calculate a more precise Hausdorff distance between two geometries,"]
    #[doc = " by densifying the inputs before computation."]
    #[doc = " [Hausdorff distance](https://en.wikipedia.org/wiki/Hausdorff_distance)"]
    #[doc = " is the largest distance between two geometries."]
    #[doc = " \\param[in] g1 Input geometry"]
    #[doc = " \\param[in] g2 Input geometry"]
    #[doc = " \\param[in] densifyFrac The largest % of the overall line length that"]
    #[doc = "            any given two-point segment should be"]
    #[doc = " \\param[out] dist Pointer to be filled in with distance result"]
    #[doc = " \\return 1 on success, 0 on exception."]
    #[doc = " \\see geos::algorithm::distance::DiscreteHausdorffDistance"]
    pub fn GEOSHausdorffDistanceDensify(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        densifyFrac: f64,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Calculate the"]
    #[doc = " [Frechet distance](https://en.wikipedia.org/wiki/Fr%C3%A9chet_distance)"]
    #[doc = " between two geometries,"]
    #[doc = " a similarity measure for linear features."]
    #[doc = " \\param[in] g1 Input geometry"]
    #[doc = " \\param[in] g2 Input geometry"]
    #[doc = " \\param[out] dist Pointer to be filled in with distance result"]
    #[doc = " \\return 1 on success, 0 on exception."]
    #[doc = " \\see geos::algorithm::distance::DiscreteFrechetDistance"]
    pub fn GEOSFrechetDistance(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Calculate the"]
    #[doc = " [Frechet distance](https://en.wikipedia.org/wiki/Fr%C3%A9chet_distance)"]
    #[doc = " between two geometries,"]
    #[doc = " a similarity measure for linear features. For more precision, first"]
    #[doc = " densify the inputs."]
    #[doc = " \\param[in] g1 Input geometry"]
    #[doc = " \\param[in] g2 Input geometry"]
    #[doc = " \\param[in] densifyFrac The largest % of the overall line length that"]
    #[doc = "            any given two-point segment should be"]
    #[doc = " \\param[out] dist Pointer to be filled in with distance result"]
    #[doc = " \\return 1 on success, 0 on exception."]
    #[doc = " \\see geos::algorithm::distance::DiscreteFrechetDistance"]
    pub fn GEOSFrechetDistanceDensify(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        densifyFrac: f64,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Distance of point projected onto line from the start of the line."]
    #[doc = " \\param line linear target of projection"]
    #[doc = " \\param point point to be projected onto 'g'"]
    #[doc = " \\return distance along line that point projects to, -1 on exception"]
    #[doc = ""]
    #[doc = " \\note Line parameter must be a LineString."]
    pub fn GEOSProject(line: *const GEOSGeometry, point: *const GEOSGeometry) -> f64;
}
extern "C" {
    #[doc = " Measuring from start of line, return point that is distance"]
    #[doc = " the start. Line parameter must be a LineString."]
    #[doc = " The returned point is not guaranteed to intersect the line due to limitations"]
    #[doc = " of floating point calculations."]
    #[doc = " \\param line linear target of projection"]
    #[doc = " \\param d distance from start of line to created point"]
    #[doc = " \\return The point \\ref GEOSGeometry that is distance from the start of line."]
    #[doc = " Caller takes ownership of returned geometry."]
    pub fn GEOSInterpolate(line: *const GEOSGeometry, d: f64) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Project point to line and calculate the **proportion** of"]
    #[doc = " the line the point is from the start. For example, a point that"]
    #[doc = " projects to the middle of a line would be return 0.5."]
    #[doc = " \\param line linear target of projection"]
    #[doc = " \\param point the point to project"]
    #[doc = " \\return The proportion of the overall line length that the projected"]
    #[doc = " point falls at."]
    pub fn GEOSProjectNormalized(line: *const GEOSGeometry, point: *const GEOSGeometry) -> f64;
}
extern "C" {
    #[doc = " Measuring from start of line, return point that is a proportion"]
    #[doc = " the start. Line parameter must be a LineString."]
    #[doc = " \\param line linear target of projection"]
    #[doc = " \\param proportion The proportion from the start of line to created point"]
    #[doc = " \\return The point \\ref GEOSGeometry that is distance from the start of line."]
    #[doc = " Caller takes ownership of returned geometry."]
    pub fn GEOSInterpolateNormalized(
        line: *const GEOSGeometry,
        proportion: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Returns the intersection of two geometries: the set of points"]
    #[doc = " that fall within **both** geometries."]
    #[doc = " \\param g1 one of the geometries"]
    #[doc = " \\param g2 the other geometry"]
    #[doc = " \\return A newly allocated geometry of the intersection. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::operation::overlayng::OverlayNG"]
    pub fn GEOSIntersection(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Returns the intersection of two geometries: the set of points"]
    #[doc = " that fall within **both** geometries. All the vertices of the output"]
    #[doc = " geometry must fall on the grid defined by the gridSize, and the"]
    #[doc = " output will be a valid geometry."]
    #[doc = " \\param g1 one of the geometries"]
    #[doc = " \\param g2 the other geometry"]
    #[doc = " \\param gridSize the cell size of the precision grid"]
    #[doc = " \\return A newly allocated geometry of the intersection. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::operation::overlayng::OverlayNG"]
    pub fn GEOSIntersectionPrec(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        gridSize: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Returns the difference of two geometries A and B: the set of points"]
    #[doc = " that fall within A but **not** within B."]
    #[doc = " \\param ga the base geometry"]
    #[doc = " \\param gb the geometry to subtract from it"]
    #[doc = " \\return A newly allocated geometry of the difference. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::operation::overlayng::OverlayNG"]
    pub fn GEOSDifference(ga: *const GEOSGeometry, gb: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Returns the difference of two geometries A and B: the set of points"]
    #[doc = " that fall within A but **not** within B."]
    #[doc = " All the vertices of the output"]
    #[doc = " geometry must fall on the grid defined by the gridSize, and the"]
    #[doc = " output will be a valid geometry."]
    #[doc = " \\param ga one of the geometries"]
    #[doc = " \\param gb the other geometry"]
    #[doc = " \\param gridSize the cell size of the precision grid"]
    #[doc = " \\return A newly allocated geometry of the difference. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::operation::overlayng::OverlayNG"]
    pub fn GEOSDifferencePrec(
        ga: *const GEOSGeometry,
        gb: *const GEOSGeometry,
        gridSize: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Returns the symmetric difference of two geometries A and B: the set of points"]
    #[doc = " that fall in A but **not** within B and the set of points that fall in B but"]
    #[doc = " **not** in A."]
    #[doc = " \\param ga geometry A"]
    #[doc = " \\param gb geometry B"]
    #[doc = " \\return A newly allocated geometry of the symmetric difference. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::operation::overlayng::OverlayNG"]
    pub fn GEOSSymDifference(ga: *const GEOSGeometry, gb: *const GEOSGeometry)
        -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Returns the symmetric difference of two geometries A and B: the set of points"]
    #[doc = " that fall in A but **not** within B and the set of points that fall in B but"]
    #[doc = " **not** in A."]
    #[doc = " All the vertices of the output"]
    #[doc = " geometry must fall on the grid defined by the gridSize, and the"]
    #[doc = " output will be a valid geometry."]
    #[doc = " \\param ga one of the geometries"]
    #[doc = " \\param gb the other geometry"]
    #[doc = " \\param gridSize the cell size of the precision grid"]
    #[doc = " \\return A newly allocated geometry of the symmetric difference. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::operation::overlayng::OverlayNG"]
    pub fn GEOSSymDifferencePrec(
        ga: *const GEOSGeometry,
        gb: *const GEOSGeometry,
        gridSize: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Returns the union of two geometries A and B: the set of points"]
    #[doc = " that fall in A **or** within B."]
    #[doc = " \\param ga geometry A"]
    #[doc = " \\param gb geometry B"]
    #[doc = " \\return A newly allocated geometry of the union. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::operation::overlayng::OverlayNG"]
    pub fn GEOSUnion(ga: *const GEOSGeometry, gb: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Returns the union of two geometries A and B: the set of points"]
    #[doc = " that fall in A **or** within B."]
    #[doc = " All the vertices of the output"]
    #[doc = " geometry must fall on the grid defined by the gridSize, and the"]
    #[doc = " output will be a valid geometry."]
    #[doc = " \\param ga one of the geometries"]
    #[doc = " \\param gb the other geometry"]
    #[doc = " \\param gridSize the cell size of the precision grid"]
    #[doc = " \\return A newly allocated geometry of the union. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::operation::overlayng::OverlayNG"]
    pub fn GEOSUnionPrec(
        ga: *const GEOSGeometry,
        gb: *const GEOSGeometry,
        gridSize: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Returns the union of all components of a single geometry. Usually"]
    #[doc = " used to convert a collection into the smallest set of polygons"]
    #[doc = " that cover the same area."]
    #[doc = " \\param g The input geometry"]
    #[doc = " \\return A newly allocated geometry of the union. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::operation::overlayng::OverlayNG"]
    pub fn GEOSUnaryUnion(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Returns the union of all components of a single geometry. Usually"]
    #[doc = " used to convert a collection into the smallest set of polygons"]
    #[doc = " that cover the same area."]
    #[doc = " All the vertices of the output"]
    #[doc = " geometry must fall on the grid defined by the gridSize, and the"]
    #[doc = " output will be a valid geometry."]
    #[doc = " \\param g input geometry"]
    #[doc = " \\param gridSize the cell size of the precision grid"]
    #[doc = " \\return A newly allocated geometry of the union. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::operation::overlayng::OverlayNG"]
    pub fn GEOSUnaryUnionPrec(g: *const GEOSGeometry, gridSize: f64) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Optimized union algorithm for polygonal inputs that are correctly"]
    #[doc = " noded and do not overlap. It will generate an error (return NULL)"]
    #[doc = " for inputs that do not satisfy this constraint."]
    #[doc = " \\param g The input geometry"]
    #[doc = " \\return A geometry that covers all the points of the input geometry."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    pub fn GEOSCoverageUnion(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Intersection optimized for a rectangular clipping polygon."]
    #[doc = " Supposed to be faster than using GEOSIntersection(). Not"]
    #[doc = " guaranteed to return valid results."]
    #[doc = " \\param g The input geometry to be clipped"]
    #[doc = " \\param xmin Left bound of clipping rectangle"]
    #[doc = " \\param ymin Lower bound of clipping rectangle"]
    #[doc = " \\param xmax Right bound of clipping rectangle"]
    #[doc = " \\param ymax Upper bound of clipping rectangle"]
    #[doc = " \\return The clipped geometry or NULL on exception"]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::operation::intersection::RectangleIntersection"]
    pub fn GEOSClipByRect(
        g: *const GEOSGeometry,
        xmin: f64,
        ymin: f64,
        xmax: f64,
        ymax: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Find paths shared between the two given lineal geometries."]
    #[doc = ""]
    #[doc = " Returns a GeometryCollection having two elements:"]
    #[doc = ""]
    #[doc = " - first element is a MultiLineString containing shared paths"]
    #[doc = "   having the _same_ direction on both inputs"]
    #[doc = " - second element is a MultiLineString containing shared paths"]
    #[doc = "   having the _opposite_ direction on the two inputs"]
    #[doc = ""]
    #[doc = " \\param g1 An input geometry"]
    #[doc = " \\param g2 An input geometry"]
    #[doc = " \\return The shared paths"]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::operation::sharedpaths::SharedPathsOp"]
    pub fn GEOSSharedPaths(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Buffer a geometry."]
    #[doc = " \\param g The input geometry to be buffered."]
    #[doc = " \\param width The distance by which to expand the geometry (or contract)"]
    #[doc = "        if the value is negative."]
    #[doc = " \\param quadsegs The number of segments per quadrant to generate. More"]
    #[doc = "        segments provides a more \"precise\" buffer at the expense of size."]
    #[doc = " \\return A \\ref GEOSGeometry of the buffered result."]
    #[doc = " NULL on exception. Caller is responsible for freeing with GEOSGeom_destroy()."]
    pub fn GEOSBuffer(
        g: *const GEOSGeometry,
        width: f64,
        quadsegs: libc::c_int,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Create a default GEOSBufferParams object for controlling the shape"]
    #[doc = " of buffered generated by \\ref GEOSBuffer."]
    #[doc = " \\return A newly allocated GEOSBufferParams. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSBufferParams_destroy()."]
    pub fn GEOSBufferParams_create() -> *mut GEOSBufferParams;
}
extern "C" {
    #[doc = " Destroy a GEOSBufferParams and free all associated memory."]
    #[doc = " \\param parms The object to destroy."]
    pub fn GEOSBufferParams_destroy(parms: *mut GEOSBufferParams);
}
extern "C" {
    #[doc = " Set the end cap type of a GEOSBufferParams to the desired style,"]
    #[doc = " which must be one enumerated in \\ref GEOSBufCapStyles."]
    #[doc = " \\return 0 on exception, 1 on success."]
    pub fn GEOSBufferParams_setEndCapStyle(
        p: *mut GEOSBufferParams,
        style: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the join type of a GEOSBufferParams to the desired style,"]
    #[doc = " which must be one enumerated in \\ref GEOSBufJoinStyles."]
    #[doc = " \\return 0 on exception, 1 on success."]
    pub fn GEOSBufferParams_setJoinStyle(
        p: *mut GEOSBufferParams,
        joinStyle: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the mitre limit of a GEOSBufferParams to the desired size."]
    #[doc = " For acute angles, a mitre join can extend very very far from"]
    #[doc = " the input geometry, which is probably not desired. The"]
    #[doc = " mitre limit places an upper bound on that."]
    #[doc = " \\param p The GEOSBufferParams to operate on"]
    #[doc = " \\param mitreLimit The limit to set"]
    #[doc = " \\return 0 on exception, 1 on success."]
    pub fn GEOSBufferParams_setMitreLimit(p: *mut GEOSBufferParams, mitreLimit: f64)
        -> libc::c_int;
}
extern "C" {
    #[doc = " Set the number of segments to use to stroke each quadrant"]
    #[doc = " of circular arcs generated by the buffering process. More"]
    #[doc = " segments means a smoother output, but with larger size."]
    #[doc = " \\param p The GEOSBufferParams to operate on"]
    #[doc = " \\param quadSegs Number of segments per quadrant"]
    #[doc = " \\return 0 on exception, 1 on success."]
    pub fn GEOSBufferParams_setQuadrantSegments(
        p: *mut GEOSBufferParams,
        quadSegs: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Sets whether the computed buffer should be single-sided."]
    #[doc = " A single-sided buffer is constructed on only one side of each input line."]
    #[doc = " \\see geos::operation::buffer::BufferParameters::setSingleSided"]
    #[doc = " \\param p The GEOSBufferParams to operate on"]
    #[doc = " \\param singleSided Set to 1 for single-sided output 0 otherwise"]
    #[doc = " \\return 0 on exception, 1 on success."]
    pub fn GEOSBufferParams_setSingleSided(
        p: *mut GEOSBufferParams,
        singleSided: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Generates a buffer using the special parameters in the GEOSBufferParams"]
    #[doc = " \\param g The geometry to buffer"]
    #[doc = " \\param p The parameters to apply to the buffer process"]
    #[doc = " \\param width The buffer distance"]
    #[doc = " \\return The buffered geometry, or NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    pub fn GEOSBufferWithParams(
        g: *const GEOSGeometry,
        p: *const GEOSBufferParams,
        width: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Generate a buffer using the provided style parameters."]
    #[doc = " \\param g The geometry to buffer"]
    #[doc = " \\param width Width of the buffer"]
    #[doc = " \\param quadsegs Number of segments per quadrant"]
    #[doc = " \\param endCapStyle See \\ref GEOSBufCapStyles"]
    #[doc = " \\param joinStyle See \\ref GEOSBufJoinStyles"]
    #[doc = " \\param mitreLimit See GEOSBufferParams_setMitreLimit"]
    #[doc = " \\return The buffered geometry, or NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    pub fn GEOSBufferWithStyle(
        g: *const GEOSGeometry,
        width: f64,
        quadsegs: libc::c_int,
        endCapStyle: libc::c_int,
        joinStyle: libc::c_int,
        mitreLimit: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Generates offset curve line(s) for a geometry."]
    #[doc = " Handles all geometry types as input."]
    #[doc = ""]
    #[doc = " - For a LineString the result is a LineString."]
    #[doc = " - For a Point the result is an empty LineString."]
    #[doc = " - For a Polygon the result is the boundary lines(s) of the polygon buffered to the offset distance"]
    #[doc = "   (which may be a MultiLineString)."]
    #[doc = " - For a collection the result is a collection of the element offset curves."]
    #[doc = " \\param g The linear geometry to offset from"]
    #[doc = " \\param width Distance to offset from the curve."]
    #[doc = "        Negative for a right-side offset."]
    #[doc = "        Positive for a left-side offset."]
    #[doc = " \\param quadsegs Number of segments per quadrant"]
    #[doc = " \\param joinStyle See \\ref GEOSBufJoinStyles"]
    #[doc = " \\param mitreLimit See GEOSBufferParams_setMitreLimit"]
    #[doc = " \\return The offset geometry. Returns NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::operation::buffer::BufferBuilder::bufferLineSingleSided"]
    pub fn GEOSOffsetCurve(
        g: *const GEOSGeometry,
        width: f64,
        quadsegs: libc::c_int,
        joinStyle: libc::c_int,
        mitreLimit: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Returns minimum rectangular polygon that contains the geometry."]
    #[doc = " \\param g The geometry to calculate an envelope for"]
    #[doc = " \\return A newly allocated polygonal envelope. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    pub fn GEOSEnvelope(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Returns the \"boundary\" of a geometry, as defined by the DE9IM:"]
    #[doc = ""]
    #[doc = " - the boundary of a polygon is the linear rings dividing the exterior"]
    #[doc = "   from the interior"]
    #[doc = " - the boundary of a linestring is the end points"]
    #[doc = " - the boundary of a point is the point"]
    #[doc = ""]
    #[doc = " \\param g The input geometry"]
    #[doc = " \\return A newly allocated geometry of the boundary. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    pub fn GEOSBoundary(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Returns convex hull of a geometry. The smallest convex Geometry"]
    #[doc = " that contains all the points in the input Geometry"]
    #[doc = " \\param g The input geometry"]
    #[doc = " \\return A newly allocated geometry of the convex hull. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::operation::overlayng::OverlayNG"]
    pub fn GEOSConvexHull(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Returns \"concave hull\" of a geometry. The concave hull is fully"]
    #[doc = " contained within the convex hull and also contains all the"]
    #[doc = " points of the input, but in a smaller area."]
    #[doc = " The area ratio is the ratio"]
    #[doc = " of the area of the convex hull and the concave hull. Frequently"]
    #[doc = " used to convert a multi-point into a polygonal area."]
    #[doc = " that contains all the points in the input Geometry"]
    #[doc = " \\param g The input geometry"]
    #[doc = " \\param ratio The ratio value, between 0 and 1."]
    #[doc = " \\param allowHoles When non-zero, the polygonal output may contain holes."]
    #[doc = " \\return A newly allocated geometry of the concave hull. NULL on exception."]
    #[doc = " The area ratio is the ratio of the concave hull area to the convex hull area."]
    #[doc = " 1 produces the convex hull; 0 produces maximum concaveness."]
    #[doc = " The Length Ratio is a fraction determining the length of the longest"]
    #[doc = " edge in the computed hull.  1 produces the convex hull;"]
    #[doc = " 0 produces a hull with maximum concaveness"]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::algorithm::hull::ConcaveHull"]
    pub fn GEOSConcaveHull(
        g: *const GEOSGeometry,
        ratio: f64,
        allowHoles: libc::c_uint,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Computes a boundary-respecting hull of a polygonal geometry,"]
    #[doc = " with hull shape determined by a target parameter"]
    #[doc = " specifying the fraction of the input vertices retained in the result."]
    #[doc = " Larger values produce less concave results."]
    #[doc = " A value of 1 produces the convex hull; a value of 0 produces the original geometry."]
    #[doc = " An outer hull is computed if the parameter is positive,"]
    #[doc = " an inner hull is computed if it is negative."]
    #[doc = ""]
    #[doc = " \\param g the polygonal geometry to process"]
    #[doc = " \\param isOuter indicates whether to compute an outer or inner hull (1 for outer hull, 0 for inner)"]
    #[doc = " \\param vertexNumFraction the target fraction of the count of input vertices to retain in result"]
    #[doc = " \\return A newly allocated geometry of the concave hull. NULL on exception."]
    #[doc = ""]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::simplify::PolygonHullSimplifier"]
    pub fn GEOSPolygonHullSimplify(
        g: *const GEOSGeometry,
        isOuter: libc::c_uint,
        vertexNumFraction: f64,
    ) -> *mut GEOSGeometry;
}
#[doc = " See geos::simplify::PolygonHullSimplifier::hull()"]
pub const GEOSPolygonHullParameterModes_GEOSHULL_PARAM_VERTEX_RATIO: GEOSPolygonHullParameterModes =
    1;
#[doc = " See geos::simplify::PolygonHullSimplifier::hullByAreaDelta()"]
pub const GEOSPolygonHullParameterModes_GEOSHULL_PARAM_AREA_RATIO: GEOSPolygonHullParameterModes =
    2;
#[doc = " Controls the behavior of the GEOSPolygonHullSimplify parameter."]
pub type GEOSPolygonHullParameterModes = libc::c_uint;
extern "C" {
    #[doc = " Computes a topology-preserving simplified hull of a polygonal geometry,"]
    #[doc = " with hull shape determined by the parameter, controlled by a parameter"]
    #[doc = " mode, which is one defined in GEOSPolygonHullParameterModes. In general,"]
    #[doc = " larger values compute less concave results and value of 0"]
    #[doc = " produces the original geometry."]
    #[doc = " Either outer or inner hulls can be computed."]
    #[doc = ""]
    #[doc = " \\param g the polygonal geometry to process"]
    #[doc = " \\param isOuter indicates whether to compute an outer or inner hull (1 for outer hull, 0 for inner)"]
    #[doc = " \\param parameterMode the interpretation to apply to the parameter argument"]
    #[doc = " \\param parameter the target ratio of area difference to original area"]
    #[doc = " \\return A newly allocated geometry of the concave hull. NULL on exception."]
    #[doc = ""]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::simplify::PolygonHullSimplifier"]
    pub fn GEOSPolygonHullSimplifyMode(
        g: *const GEOSGeometry,
        isOuter: libc::c_uint,
        parameterMode: libc::c_uint,
        parameter: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Constructs a concave hull of a set of polygons, respecting"]
    #[doc = " the polygons as constraints."]
    #[doc = ""]
    #[doc = " A concave hull is a possibly non-convex polygon containing all the input polygons."]
    #[doc = " A given set of polygons has a sequence of hulls of increasing concaveness,"]
    #[doc = " determined by a numeric target parameter."]
    #[doc = " The computed hull \"fills the gap\" between the polygons,"]
    #[doc = " and does not intersect their interior."]
    #[doc = ""]
    #[doc = " The concave hull is constructed by removing the longest outer edges"]
    #[doc = " of the Delaunay Triangulation of the space between the polygons,"]
    #[doc = " until the target criterion parameter is reached."]
    #[doc = ""]
    #[doc = " \"Maximum Edge Length\" constrains the length of the longest edge between the polygons to be no larger than this value."]
    #[doc = ""]
    #[doc = " \\param g the valid MultiPolygon geometry to process"]
    #[doc = " \\param lengthRatio determine the Maximum Edge Length as a"]
    #[doc = "        fraction of the difference between the longest and"]
    #[doc = "        shortest edge lengths between the polygons."]
    #[doc = "        This normalizes the Maximum Edge Length to be scale-free."]
    #[doc = "        A value of 1 produces the convex hull; a value of 0 produces"]
    #[doc = "        the original polygons."]
    #[doc = " \\param isHolesAllowed is the concave hull allowed to contain holes?"]
    #[doc = " \\param isTight does the hull follow the outer boundaries of the input polygons."]
    #[doc = " \\return A newly allocated geometry of the concave hull. NULL on exception."]
    #[doc = ""]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::algorithm::hull::ConcaveHullOfPolygons"]
    #[doc = ""]
    #[doc = " The input polygons *must* form a *valid* MultiPolygon"]
    #[doc = " (i.e. they must be non-overlapping)."]
    pub fn GEOSConcaveHullOfPolygons(
        g: *const GEOSGeometry,
        lengthRatio: f64,
        isTight: libc::c_uint,
        isHolesAllowed: libc::c_uint,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Returns the minimum rotated rectangular POLYGON which encloses"]
    #[doc = " the input geometry. The rectangle has width equal to the"]
    #[doc = " minimum diameter, and a longer length. If the convex hill of"]
    #[doc = " the input is degenerate (a line or point) a linestring or point"]
    #[doc = " is returned. The minimum rotated rectangle can be used as an"]
    #[doc = " extremely generalized representation for the given geometry."]
    #[doc = " \\param g The input geometry"]
    #[doc = " \\return A newly allocated geometry of the rotated envelope. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    pub fn GEOSMinimumRotatedRectangle(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Constructs the \"maximum inscribed circle\" (MIC) for a polygonal geometry,"]
    #[doc = " up to a specified tolerance."]
    #[doc = " The MIC is determined by a point in the interior of the area"]
    #[doc = " which has the farthest distance from the area boundary, along with a boundary point at that distance."]
    #[doc = " In the context of geography the center of the MIC is known as the"]
    #[doc = " \"pole of inaccessibility\". A cartographic use case is to determine a suitable point"]
    #[doc = " to place a map label within a polygon."]
    #[doc = " The radius length of the MIC is a  measure of how \"narrow\" a polygon is. It is the"]
    #[doc = " distance at which the negative buffer becomes empty."]
    #[doc = " The class supports polygons with holes and multipolygons."]
    #[doc = " The implementation uses a successive-approximation technique over a grid of square cells covering the area geometry."]
    #[doc = " The grid is refined using a branch-and-bound algorithm. Point containment and distance are computed in a performant"]
    #[doc = " way by using spatial indexes."]
    #[doc = " Returns a two-point linestring, with one point at the center of the inscribed circle and the other"]
    #[doc = " on the boundary of the inscribed circle."]
    #[doc = " \\param g Input geometry"]
    #[doc = " \\param tolerance Stop the algorithm when the search area is smaller than this tolerance"]
    #[doc = " \\return A newly allocated geometry of the MIC. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::algorithm::construct::MaximumInscribedCircle"]
    pub fn GEOSMaximumInscribedCircle(g: *const GEOSGeometry, tolerance: f64) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Constructs the \"largest empty circle\" (LEC) for a set of obstacle geometries, up to a"]
    #[doc = " specified tolerance. The obstacles are point and line geometries. Polygonal obstacles willl"]
    #[doc = " be treated as linear features."]
    #[doc = " The LEC is the largest circle which  has its **center** inside the boundary,"]
    #[doc = " and whose interior does not intersect with any obstacle. If no boundary is provided, the"]
    #[doc = " convex hull of the obstacles is used as the boundary."]
    #[doc = " The LEC center is the point in the interior of the boundary which has the farthest distance from"]
    #[doc = " the obstacles (up to tolerance). The LEC is determined by the center point and a point lying on an"]
    #[doc = " obstacle indicating the circle radius."]
    #[doc = " The implementation uses a successive-approximation technique over a grid of square cells covering the obstacles and boundary."]
    #[doc = " The grid is refined using a branch-and-bound algorithm.  Point containment and distance are computed in a performant"]
    #[doc = " way by using spatial indexes."]
    #[doc = " Returns a two-point linestring, with the start point at the center of the inscribed circle and the end"]
    #[doc = " on the boundary of the inscribed circle."]
    #[doc = " \\param obstacles The geometries that the LEC must fit within without covering"]
    #[doc = " \\param boundary The area within which the LEC must reside"]
    #[doc = " \\param tolerance Stop the algorithm when the search area is smaller than this tolerance"]
    #[doc = " \\return A newly allocated geometry of the LEC. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::algorithm::construct::LargestEmptyCircle"]
    pub fn GEOSLargestEmptyCircle(
        obstacles: *const GEOSGeometry,
        boundary: *const GEOSGeometry,
        tolerance: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Returns a linestring geometry which represents the minimum diameter of the geometry."]
    #[doc = " The minimum diameter is defined to be the width of the smallest band that"]
    #[doc = " contains the geometry, where a band is a strip of the plane defined"]
    #[doc = " by two parallel lines. This can be thought of as the smallest hole that the geometry"]
    #[doc = " can be moved through, with a single rotation."]
    #[doc = " \\param g The input geometry"]
    #[doc = " \\return A newly allocated geometry of the LEC. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::algorithm::MinimumDiameter"]
    pub fn GEOSMinimumWidth(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Returns a point that is inside the boundary of a polygonal geometry."]
    #[doc = " \\param g The input geometry"]
    #[doc = " \\return A point that is inside the input"]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::algorithm::InteriorPointArea"]
    pub fn GEOSPointOnSurface(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Returns a point at the center of mass of the input."]
    #[doc = " \\param g The input geometry"]
    #[doc = " \\return A point at the center of mass of the input"]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::algorithm::Centroid"]
    pub fn GEOSGetCentroid(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Returns a geometry which represents the \"minimum bounding circle\","]
    #[doc = " the smallest circle that contains the input."]
    #[doc = " \\param[in] g The input geometry"]
    #[doc = " \\param[out] radius Pointer will be filled with output radius."]
    #[doc = " \\param[out] center Pointer will be filled with output circle center. Caller must free."]
    #[doc = " \\return The circle geometry or NULL on exception"]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::algorithm::MinimumBoundingCircle::getCircle"]
    pub fn GEOSMinimumBoundingCircle(
        g: *const GEOSGeometry,
        radius: *mut f64,
        center: *mut *mut GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Return a Delaunay triangulation of the vertices of the given geometry."]
    #[doc = ""]
    #[doc = " \\param g the input geometry whose vertices will be used as \"sites\""]
    #[doc = " \\param tolerance optional snapping tolerance to use for improved robustness"]
    #[doc = " \\param onlyEdges if non-zero will return a MultiLineString, otherwise it will"]
    #[doc = "                  return a GeometryCollection containing triangular Polygons."]
    #[doc = ""]
    #[doc = " \\return A newly allocated geometry. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    pub fn GEOSDelaunayTriangulation(
        g: *const GEOSGeometry,
        tolerance: f64,
        onlyEdges: libc::c_int,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Return a constrained Delaunay triangulation of the vertices of the"]
    #[doc = " given polygon(s)."]
    #[doc = " For non-polygonal inputs, returns an empty geometry collection."]
    #[doc = ""]
    #[doc = " \\param g the input geometry whose rings will be used as input"]
    #[doc = " \\return A newly allocated geometry. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    pub fn GEOSConstrainedDelaunayTriangulation(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Returns the Voronoi polygons of the vertices of the given geometry."]
    #[doc = ""]
    #[doc = " \\param g the input geometry whose vertices will be used as sites."]
    #[doc = " \\param tolerance snapping tolerance to use for improved robustness"]
    #[doc = " \\param onlyEdges whether to return only edges of the voronoi cells"]
    #[doc = " \\param env clipping envelope for the returned diagram, automatically"]
    #[doc = "            determined if env is NULL."]
    #[doc = "            The diagram will be clipped to the larger"]
    #[doc = "            of this envelope or an envelope surrounding the sites."]
    #[doc = ""]
    #[doc = " \\return A newly allocated geometry. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    pub fn GEOSVoronoiDiagram(
        g: *const GEOSGeometry,
        env: *const GEOSGeometry,
        tolerance: f64,
        onlyEdges: libc::c_int,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " For linear inputs, returns a new geometry in which no lines cross"]
    #[doc = " each other, and all touching occurs at end points."]
    #[doc = " \\param g The input geometry"]
    #[doc = " \\return The noded geometry or NULL on exception"]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::noding::GeometryNoder::node"]
    pub fn GEOSNode(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Polygonizes a set of Geometries which contain linework that"]
    #[doc = " represents the edges of a planar graph."]
    #[doc = ""]
    #[doc = " All types of Geometry are accepted as input; the constituent"]
    #[doc = " linework is extracted as the edges to be polygonized."]
    #[doc = ""]
    #[doc = " The edges must be correctly noded; that is, they must only meet"]
    #[doc = " at their endpoints. Polygonization will accept incorrectly noded"]
    #[doc = " input but will not form polygons from non-noded edges, and reports"]
    #[doc = " them as errors."]
    #[doc = ""]
    #[doc = " The Polygonizer reports the following kinds of errors:"]
    #[doc = ""]
    #[doc = " - Dangles - edges which have one or both ends which are"]
    #[doc = "   not incident on another edge endpoint"]
    #[doc = " - Cut Edges - edges which are connected at both ends but"]
    #[doc = "   which do not form part of a polygon"]
    #[doc = " - Invalid Ring Lines - edges which form rings which are invalid"]
    #[doc = "   (e.g. the component lines contain a self-intersection)"]
    #[doc = ""]
    #[doc = " Errors are reported to output parameters \"cuts\", \"dangles\" and"]
    #[doc = " \"invalid\" (if not-null). Formed polygons are returned as a"]
    #[doc = " collection. NULL is returned on exception. All returned"]
    #[doc = " geometries must be destroyed by caller."]
    #[doc = ""]
    #[doc = " The GEOSPolygonize_valid() variant allows extracting only polygons"]
    #[doc = " which form a valid polygonal result. The set of extracted polygons"]
    #[doc = " is guaranteed to be edge-disjoint. This is useful when it is known"]
    #[doc = " that the input lines form a valid polygonal geometry (which may"]
    #[doc = " include holes or nested polygons)."]
    #[doc = ""]
    #[doc = " \\param geoms Array of linear geometries to polygons. Caller retains ownersihp of both array container and objects."]
    #[doc = " \\param ngeoms Size of the geoms array."]
    #[doc = " \\return The polygonal output geometry."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::operation::polygonize::Polygonizer"]
    pub fn GEOSPolygonize(
        geoms: *const *const GEOSGeometry,
        ngeoms: libc::c_uint,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Same polygonizing behavior as GEOSPolygonize(), but only returning results"]
    #[doc = " that are valid."]
    #[doc = ""]
    #[doc = " \\param geoms Array of linear geometries to polygons. Caller retains ownersihp of both array container and objects."]
    #[doc = " \\param ngeoms Size of the geoms array."]
    #[doc = " \\return The polygonal output geometry."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::operation::polygonize::Polygonizer"]
    pub fn GEOSPolygonize_valid(
        geoms: *const *const GEOSGeometry,
        ngeoms: libc::c_uint,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Perform the polygonization as GEOSPolygonize() but return only the"]
    #[doc = " \"cut edges\", the linear features that are connected at both ends,"]
    #[doc = " do *not* participate in the final polygon."]
    #[doc = ""]
    #[doc = " \\param geoms Array of linear geometries to polygons. Caller retains ownersihp of both array container and objects."]
    #[doc = " \\param ngeoms Size of the geoms array."]
    #[doc = " \\return The \"cut edges\""]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::operation::polygonize::Polygonizer"]
    pub fn GEOSPolygonizer_getCutEdges(
        geoms: *const *const GEOSGeometry,
        ngeoms: libc::c_uint,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Perform the polygonization as GEOSPolygonize() and return the"]
    #[doc = " polygonal result as well as all extra ouputs."]
    #[doc = ""]
    #[doc = " \\param[in] input A single geometry with all the input lines to polygonize."]
    #[doc = " \\param[out] cuts Pointer to hold \"cut edges\", connected on both ends but not part of output. Caller must free."]
    #[doc = " \\param[out] dangles Pointer to hold \"dangles\", connected one end but not part of output. Caller must free."]
    #[doc = " \\param[out] invalid Pointer to hold invalid outputs, polygons formed but not valid. Caller must free."]
    #[doc = " \\return The polygonal valid output"]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::operation::polygonize::Polygonizer"]
    pub fn GEOSPolygonize_full(
        input: *const GEOSGeometry,
        cuts: *mut *mut GEOSGeometry,
        dangles: *mut *mut GEOSGeometry,
        invalid: *mut *mut GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Perform a polygonization using all the linework, assuming that"]
    #[doc = " rings contained within rings are empty holes, rather then"]
    #[doc = " extra polygons."]
    #[doc = " \\param g The input linework"]
    #[doc = " \\return The polygonal output"]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::operation::polygonize::BuildArea"]
    pub fn GEOSBuildArea(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Densifies a geometry using a given distance tolerance."]
    #[doc = " Additional vertices will be added to every line segment"]
    #[doc = " that is greater this tolerance; these vertices will"]
    #[doc = " evenly subdivide that segment."]
    #[doc = " Only linear components of input geometry are densified."]
    #[doc = " \\param g The geometry to densify"]
    #[doc = " \\param tolerance the distance tolerance to densify"]
    #[doc = " \\return The densified geometry, or NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    pub fn GEOSDensify(g: *const GEOSGeometry, tolerance: f64) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Sews together a set of fully noded LineStrings"]
    #[doc = " removing any cardinality 2 nodes in the linework."]
    #[doc = " \\param g The input linework"]
    #[doc = " \\return The merged linework"]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::operation::linemerge::LineMerger"]
    pub fn GEOSLineMerge(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Sews together a set of fully noded LineStrings"]
    #[doc = " removing any cardinality 2 nodes in the linework"]
    #[doc = " only if possible without changing order of points."]
    #[doc = " \\param g The input linework"]
    #[doc = " \\return The merged linework"]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::operation::linemerge::LineMerger"]
    pub fn GEOSLineMergeDirected(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " For geometries with coordinate sequences, reverses the order"]
    #[doc = " of the sequences. Converts CCW rings to CW. Reverses direction"]
    #[doc = " of LineStrings."]
    #[doc = " \\param g The input geometry"]
    #[doc = " \\return The reversed geometry"]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    pub fn GEOSReverse(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Apply the"]
    #[doc = " [Douglas/Peucker algorithm](https://en.wikipedia.org/wiki/RamerDouglasPeucker_algorithm)"]
    #[doc = " to the coordinate sequences of the input geometry."]
    #[doc = " Removes \"unnecessary\" vertices, vertices"]
    #[doc = " that are co-linear within the tolerance distance."]
    #[doc = " \\param g The input geometry"]
    #[doc = " \\param tolerance The tolerance to apply. Larger tolerance leads to simpler output."]
    #[doc = " \\return The simplified geometry"]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::simplify::DouglasPeuckerSimplifier"]
    pub fn GEOSSimplify(g: *const GEOSGeometry, tolerance: f64) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Apply the"]
    #[doc = " [Douglas/Peucker algorithm](https://en.wikipedia.org/wiki/RamerDouglasPeucker_algorithm)"]
    #[doc = " to the coordinate sequences of the input geometry."]
    #[doc = " Removes \"unnecessary\" vertices, vertices"]
    #[doc = " that are co-linear within the tolerance distance."]
    #[doc = " Returns a valid output geometry, checking for collapses, ring-intersections, etc"]
    #[doc = " and attempting to avoid. More computationally expensive than GEOSSimplify()"]
    #[doc = " \\param g The input geometry"]
    #[doc = " \\param tolerance The tolerance to apply. Larger tolerance leads to simpler output."]
    #[doc = " \\return The simplified geometry"]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    #[doc = " \\see geos::simplify::DouglasPeuckerSimplifier"]
    pub fn GEOSTopologyPreserveSimplify(
        g: *const GEOSGeometry,
        tolerance: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Return all distinct vertices of input geometry as a MultiPoint."]
    #[doc = " Note that only 2 dimensions of the vertices are considered when"]
    #[doc = " testing for equality."]
    #[doc = " \\param g The input geometry"]
    #[doc = " \\return The distinct points"]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    pub fn GEOSGeom_extractUniquePoints(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Calculate the"]
    #[doc = " [Hilbert code](https://en.wikipedia.org/wiki/Hilbert_curve)"]
    #[doc = " of the centroid of a geometry relative to an extent."]
    #[doc = " This allows sorting geometries in a deterministic way, such that similar Hilbert codes are"]
    #[doc = " likely to be near each other in two-dimensional space."]
    #[doc = " The caller must ensure that the geometry is contained within the extent."]
    #[doc = " \\param[in] geom Input geometry, must be non-empty"]
    #[doc = " \\param[in] extent Extent within which to calculate the Hilbert code for geom"]
    #[doc = " \\param[in] level The level of precision of the Hilbert curve, up to 16"]
    #[doc = " \\param[out] code Pointer to be filled in with Hilbert code result"]
    #[doc = " \\return 1 on success, 0 on exception."]
    pub fn GEOSHilbertCode(
        geom: *const GEOSGeometry,
        extent: *const GEOSGeometry,
        level: libc::c_uint,
        code: *mut libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Apply XY coordinate transform callback to all coordinates in a copy of"]
    #[doc = " input geometry.  If the callback returns an error, returned geometry will be"]
    #[doc = " NULL.  Z values, if present, are not modified by this function."]
    #[doc = " \\param[in] g Input geometry"]
    #[doc = " \\param[in] callback a function to be executed for each coordinate in the"]
    #[doc = "geometry.  The callback takes 3 parameters: x and y coordinate"]
    #[doc = "values to be updated and a void userdata pointer."]
    #[doc = " \\param userdata an optional pointer to pe passed to 'callback' as an argument"]
    #[doc = " \\return a copy of the input geometry with transformed coordinates."]
    #[doc = " Caller must free with GEOSGeom_destroy()."]
    pub fn GEOSGeom_transformXY(
        g: *const GEOSGeometry,
        callback: GEOSTransformXYCallback,
        userdata: *mut libc::c_void,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Snap first geometry onto second within the given tolerance."]
    #[doc = " \\param input An input geometry"]
    #[doc = " \\param snap_target A geometry to snap the input to"]
    #[doc = " \\param tolerance Snapping tolerance"]
    #[doc = " \\return The snapped verion of the input. NULL on exception."]
    #[doc = " Caller is responsible for freeing with GEOSGeom_destroy()."]
    pub fn GEOSSnap(
        input: *const GEOSGeometry,
        snap_target: *const GEOSGeometry,
        tolerance: f64,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Change the coordinate precision of a geometry. This will"]
    #[doc = " affect the precision of the existing geometry as well as"]
    #[doc = " any geometries derived from this geometry using overlay"]
    #[doc = " functions. The output will be a valid \\ref GEOSGeometry."]
    #[doc = ""]
    #[doc = " Note that operations will always be performed in the precision"]
    #[doc = " of the geometry with higher precision (smaller \"gridSize\")."]
    #[doc = " That same precision will be attached to the operation outputs."]
    #[doc = ""]
    #[doc = " In the Default and GEOS_PREC_KEEP_COLLAPSED modes invalid input"]
    #[doc = " may cause an error to occur, unless the invalidity is below"]
    #[doc = " the scale of the requested precision"]
    #[doc = ""]
    #[doc = " There are only 3 modes. The GEOS_PREC_NO_TOPO mode"]
    #[doc = " takes precedence over GEOS_PREC_KEEP_COLLAPSED."]
    #[doc = " So the combination GEOS_PREC_NO_TOPO || GEOS_PREC_KEEP_COLLAPSED"]
    #[doc = " has the same semantics as GEOS_PREC_NO_TOPO"]
    #[doc = ""]
    #[doc = " \\param g Input geometry"]
    #[doc = " \\param gridSize cell size of grid to round coordinates to,"]
    #[doc = "        or 0 for FLOATING precision"]
    #[doc = " \\param flags The bitwise OR of members of the \\ref GEOSPrecisionRules enum"]
    #[doc = " \\return The precision reduced result."]
    #[doc = "         Caller must free with GEOSGeom_destroy()"]
    #[doc = "         NULL on exception."]
    pub fn GEOSGeom_setPrecision(
        g: *const GEOSGeometry,
        gridSize: f64,
        flags: libc::c_int,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " True if no point of either geometry touchess or is within the other."]
    #[doc = " \\param g1 Input geometry"]
    #[doc = " \\param g2 Input geometry"]
    #[doc = " \\returns 1 on true, 0 on false, 2 on exception"]
    #[doc = " \\see geos::geom::Geometry::disjoint"]
    pub fn GEOSDisjoint(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    #[doc = " True if geometries share boundaries at one or more points, but do"]
    #[doc = " not have interior overlaps."]
    #[doc = " \\param g1 Input geometry"]
    #[doc = " \\param g2 Input geometry"]
    #[doc = " \\returns 1 on true, 0 on false, 2 on exception"]
    #[doc = " \\see geos::geom::Geometry::touches"]
    pub fn GEOSTouches(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    #[doc = " True if geometries are not disjoint."]
    #[doc = " \\param g1 Input geometry"]
    #[doc = " \\param g2 Input geometry"]
    #[doc = " \\returns 1 on true, 0 on false, 2 on exception"]
    #[doc = " \\see geos::geom::Geometry::intersects"]
    pub fn GEOSIntersects(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    #[doc = " True if geometries interiors interact but their boundares do not."]
    #[doc = " Most useful for finding line crosses cases."]
    #[doc = " \\param g1 Input geometry"]
    #[doc = " \\param g2 Input geometry"]
    #[doc = " \\returns 1 on true, 0 on false, 2 on exception"]
    #[doc = " \\see geos::geom::Geometry::crosses"]
    pub fn GEOSCrosses(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    #[doc = " True if geometry g1 is completely within g2, and not"]
    #[doc = " touching the boundary of g2."]
    #[doc = " \\param g1 Input geometry"]
    #[doc = " \\param g2 Input geometry"]
    #[doc = " \\returns 1 on true, 0 on false, 2 on exception"]
    #[doc = " \\see geos::geom::Geometry::within"]
    pub fn GEOSWithin(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    #[doc = " True if geometry g2 is completely within g1."]
    #[doc = " \\param g1 Input geometry"]
    #[doc = " \\param g2 Input geometry"]
    #[doc = " \\returns 1 on true, 0 on false, 2 on exception"]
    #[doc = " \\see geos::geom::Geometry::contains"]
    pub fn GEOSContains(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    #[doc = " True if geometries share interiors but are neither"]
    #[doc = " within nor contained."]
    #[doc = " \\param g1 Input geometry"]
    #[doc = " \\param g2 Input geometry"]
    #[doc = " \\returns 1 on true, 0 on false, 2 on exception"]
    #[doc = " \\see geos::geom::Geometry::overlaps"]
    pub fn GEOSOverlaps(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    #[doc = " True if geometries cover the same space on the place."]
    #[doc = " \\param g1 Input geometry"]
    #[doc = " \\param g2 Input geometry"]
    #[doc = " \\returns 1 on true, 0 on false, 2 on exception"]
    #[doc = " \\see geos::geom::Geometry::equals"]
    pub fn GEOSEquals(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    #[doc = " True if geometry g1 is completely within g2, including possibly"]
    #[doc = " touching the boundary of g2."]
    #[doc = " \\param g1 Input geometry"]
    #[doc = " \\param g2 Input geometry"]
    #[doc = " \\returns 1 on true, 0 on false, 2 on exception"]
    #[doc = " \\see geos::geom::Geometry::covers"]
    pub fn GEOSCovers(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    #[doc = " True if geometry g2 is completely within g1, including possibly"]
    #[doc = " touching the boundary of g1."]
    #[doc = " \\param g1 Input geometry"]
    #[doc = " \\param g2 Input geometry"]
    #[doc = " \\returns 1 on true, 0 on false, 2 on exception"]
    #[doc = " \\see geos::geom::Geometry::coveredby"]
    pub fn GEOSCoveredBy(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> libc::c_char;
}
extern "C" {
    #[doc = " Determine pointwise equivalence of two geometries, by"]
    #[doc = " checking that they have identical structure"]
    #[doc = " and that each vertex of g2 is"]
    #[doc = " within the distance tolerance of the corresponding vertex in g1."]
    #[doc = " Unlike GEOSEquals(), geometries that are topologically equivalent but have different"]
    #[doc = " representations (e.g., LINESTRING (0 0, 1 1) and MULTILINESTRING ((0 0, 1 1)) ) are not"]
    #[doc = " considered equal by GEOSEqualsExact()."]
    #[doc = " \\param g1 Input geometry"]
    #[doc = " \\param g2 Input geometry"]
    #[doc = " \\param tolerance Tolerance to determine vertex equality"]
    #[doc = " \\returns 1 on true, 0 on false, 2 on exception"]
    #[doc = " \\see GEOSNormalize()"]
    pub fn GEOSEqualsExact(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        tolerance: f64,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " Calculate the DE9IM pattern for this geometry pair"]
    #[doc = " and compare against the provided pattern to check for"]
    #[doc = " consistency. If the result and pattern are consistent"]
    #[doc = " return true. The pattern may include glob \"*\" characters"]
    #[doc = " for portions that are allowed to match any value."]
    #[doc = " \\see geos::geom::Geometry::relate"]
    #[doc = " \\param g1 First geometry in pair"]
    #[doc = " \\param g2 Second geometry in pair"]
    #[doc = " \\param pat DE9IM pattern to check"]
    #[doc = " \\return 1 on true, 0 on false, 2 on exception"]
    pub fn GEOSRelatePattern(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        pat: *const libc::c_char,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " Calculate and return the DE9IM pattern for this geometry pair."]
    #[doc = " \\see geos::geom::Geometry::relate"]
    #[doc = " \\param g1 First geometry in pair"]
    #[doc = " \\param g2 Second geometry in pair"]
    #[doc = " \\return DE9IM string. Caller is responsible for freeing with GEOSFree()."]
    #[doc = "         NULL on exception"]
    pub fn GEOSRelate(g1: *const GEOSGeometry, g2: *const GEOSGeometry) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Compare two DE9IM patterns and return true if they"]
    #[doc = " are consistent."]
    #[doc = " \\param mat Complete DE9IM string (does not have \"*\")"]
    #[doc = " \\param pat Pattern to match to (may contain \"*\")"]
    #[doc = " \\return 1 on true, 0 on false, 2 on exception"]
    pub fn GEOSRelatePatternMatch(
        mat: *const libc::c_char,
        pat: *const libc::c_char,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " Calculate and return the DE9IM pattern for this geometry pair."]
    #[doc = " Apply the supplied \\ref GEOSRelateBoundaryNodeRules."]
    #[doc = " \\see geos::geom::Geometry::relate"]
    #[doc = " \\see geos::algorithm::BoundaryNodeRule"]
    #[doc = " \\param g1 First geometry in pair"]
    #[doc = " \\param g2 Second geometry in pair"]
    #[doc = " \\param bnr A member of the \\ref GEOSRelateBoundaryNodeRules enum"]
    #[doc = " \\return DE9IM string. Caller is responsible for freeing with GEOSFree()."]
    #[doc = "         NULL on exception"]
    pub fn GEOSRelateBoundaryNodeRule(
        g1: *const GEOSGeometry,
        g2: *const GEOSGeometry,
        bnr: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Create a Prepared Geometry."]
    #[doc = " The caller retains ownership of the base geometry, and after"]
    #[doc = " processing is complete, must free **both** the prepared and the"]
    #[doc = " base geometry. (Ideally, destroy the prepared geometry first, as"]
    #[doc = " it has an internal reference to the base geometry.)"]
    #[doc = ""]
    #[doc = " \\param g The base geometry to wrap in a prepared geometry."]
    #[doc = " \\return A prepared geometry. Caller is responsible for freeing with"]
    #[doc = "         GEOSPreparedGeom_destroy()"]
    pub fn GEOSPrepare(g: *const GEOSGeometry) -> *const GEOSPreparedGeometry;
}
extern "C" {
    #[doc = " Free the memory associated with a \\ref GEOSPreparedGeometry."]
    #[doc = " Caller must separately free the base \\ref GEOSGeometry used"]
    #[doc = " to create the prepared geometry."]
    #[doc = " \\param g Prepared geometry to destroy."]
    pub fn GEOSPreparedGeom_destroy(g: *const GEOSPreparedGeometry);
}
extern "C" {
    #[doc = " Using a \\ref GEOSPreparedGeometry do a high performance"]
    #[doc = " calculation of whether the provided geometry is contained."]
    #[doc = " \\param pg1 The prepared geometry"]
    #[doc = " \\param g2 The geometry to test"]
    #[doc = " \\returns 1 on true, 0 on false, 2 on exception"]
    #[doc = " \\see GEOSContains"]
    pub fn GEOSPreparedContains(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " Using a \\ref GEOSPreparedGeometry do a high performance"]
    #[doc = " calculation of whether the provided geometry is contained properly."]
    #[doc = " \\param pg1 The prepared geometry"]
    #[doc = " \\param g2 The geometry to test"]
    #[doc = " \\returns 1 on true, 0 on false, 2 on exception"]
    #[doc = " \\see GEOSContainsProperly"]
    pub fn GEOSPreparedContainsProperly(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " Using a \\ref GEOSPreparedGeometry do a high performance"]
    #[doc = " calculation of whether the provided geometry is covered by."]
    #[doc = " \\param pg1 The prepared geometry"]
    #[doc = " \\param g2 The geometry to test"]
    #[doc = " \\returns 1 on true, 0 on false, 2 on exception"]
    #[doc = " \\see GEOSCoveredBy"]
    pub fn GEOSPreparedCoveredBy(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " Using a \\ref GEOSPreparedGeometry do a high performance"]
    #[doc = " calculation of whether the provided geometry covers."]
    #[doc = " \\param pg1 The prepared geometry"]
    #[doc = " \\param g2 The geometry to test"]
    #[doc = " \\returns 1 on true, 0 on false, 2 on exception"]
    #[doc = " \\see GEOSCovers"]
    pub fn GEOSPreparedCovers(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " Using a \\ref GEOSPreparedGeometry do a high performance"]
    #[doc = " calculation of whether the provided geometry crosses."]
    #[doc = " \\param pg1 The prepared geometry"]
    #[doc = " \\param g2 The geometry to test"]
    #[doc = " \\returns 1 on true, 0 on false, 2 on exception"]
    #[doc = " \\see GEOSCrosses"]
    pub fn GEOSPreparedCrosses(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " Using a \\ref GEOSPreparedDisjoint do a high performance"]
    #[doc = " calculation of whether the provided geometry is disjoint."]
    #[doc = " \\param pg1 The prepared geometry"]
    #[doc = " \\param g2 The geometry to test"]
    #[doc = " \\returns 1 on true, 0 on false, 2 on exception"]
    #[doc = " \\see GEOSDisjoin"]
    pub fn GEOSPreparedDisjoint(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " Using a \\ref GEOSPreparedDisjoint do a high performance"]
    #[doc = " calculation of whether the provided geometry is disjoint."]
    #[doc = " \\param pg1 The prepared geometry"]
    #[doc = " \\param g2 The geometry to test"]
    #[doc = " \\returns 1 on true, 0 on false, 2 on exception"]
    #[doc = " \\see GEOSDisjoin"]
    pub fn GEOSPreparedIntersects(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " Using a \\ref GEOSPreparedDisjoint do a high performance"]
    #[doc = " calculation of whether the provided geometry overlaps."]
    #[doc = " \\param pg1 The prepared geometry"]
    #[doc = " \\param g2 The geometry to test"]
    #[doc = " \\returns 1 on true, 0 on false, 2 on exception"]
    #[doc = " \\see GEOSOverlaps"]
    pub fn GEOSPreparedOverlaps(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " Using a \\ref GEOSPreparedDisjoint do a high performance"]
    #[doc = " calculation of whether the provided geometry touches."]
    #[doc = " \\param pg1 The prepared geometry"]
    #[doc = " \\param g2 The geometry to test"]
    #[doc = " \\returns 1 on true, 0 on false, 2 on exception"]
    #[doc = " \\see GEOSTouches"]
    pub fn GEOSPreparedTouches(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " Using a \\ref GEOSPreparedDisjoint do a high performance"]
    #[doc = " calculation of whether the provided geometry is within."]
    #[doc = " \\param pg1 The prepared geometry"]
    #[doc = " \\param g2 The geometry to test"]
    #[doc = " \\returns 1 on true, 0 on false, 2 on exception"]
    #[doc = " \\see GEOSWithin"]
    pub fn GEOSPreparedWithin(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " Using a \\ref GEOSPreparedDisjoint do a high performance"]
    #[doc = " calculation to find the nearest points between the"]
    #[doc = " prepared and provided geometry."]
    #[doc = " \\param pg1 The prepared geometry"]
    #[doc = " \\param g2 The geometry to test"]
    #[doc = " \\returns A coordinate sequence containing the nearest points, or NULL on exception."]
    #[doc = "          The first point in the sequence is from the prepared geometry, and the"]
    #[doc = "          seconds is from the other argument."]
    pub fn GEOSPreparedNearestPoints(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
    ) -> *mut GEOSCoordSequence;
}
extern "C" {
    #[doc = " Using a \\ref GEOSPreparedDistance do a high performance"]
    #[doc = " calculation to find the distance points between the"]
    #[doc = " prepared and provided geometry. Useful for situations where"]
    #[doc = " one geometry is large and static and needs to be tested"]
    #[doc = " against a large number of other geometries."]
    #[doc = " \\param[in] pg1 The prepared geometry"]
    #[doc = " \\param[in] g2 The geometry to test"]
    #[doc = " \\param[out] dist Pointer to store the result in"]
    #[doc = " \\return 1 on success"]
    pub fn GEOSPreparedDistance(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
        dist: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Using a \\ref GEOSPreparedDistanceWithin do a high performance"]
    #[doc = " calculation to find whether the prepared and provided geometry"]
    #[doc = " are within the given max distance."]
    #[doc = " Useful for situations where"]
    #[doc = " one geometry is large and static and needs to be tested"]
    #[doc = " against a large number of other geometries."]
    #[doc = " \\param pg1 The prepared geometry"]
    #[doc = " \\param g2 The geometry to test"]
    #[doc = " \\param dist The max distance"]
    #[doc = " \\return 1 on success"]
    pub fn GEOSPreparedDistanceWithin(
        pg1: *const GEOSPreparedGeometry,
        g2: *const GEOSGeometry,
        dist: f64,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " Create a new \\ref GEOSSTRtree using the Sort-Tile-Recursive algorithm"]
    #[doc = " ([STRtree](https://en.wikipedia.org/wiki/R-tree))"]
    #[doc = " for two-dimensional spatial data."]
    #[doc = ""]
    #[doc = " \\param nodeCapacity The maximum number of child nodes that a node may have."]
    #[doc = "        The minimum recommended capacity value is 4."]
    #[doc = "        If unsure, use a default node capacity of 10."]
    #[doc = " \\return a pointer to the created tree"]
    pub fn GEOSSTRtree_create(nodeCapacity: usize) -> *mut GEOSSTRtree;
}
extern "C" {
    #[doc = " Insert an item into an \\ref GEOSSTRtree"]
    #[doc = ""]
    #[doc = " \\param tree the \\ref GEOSSTRtree in which the item should be inserted"]
    #[doc = " \\param g a GEOSGeometry whose envelope corresponds to the extent of 'item'. As of GEOS 3.9, this envelope will be"]
    #[doc = "       copied into the tree and the caller may destroy `g` while the tree is still in use. Before GEOS 3.9, `g`"]
    #[doc = "       must be retained until the tree is destroyed."]
    #[doc = " \\param item the item to insert into the tree"]
    #[doc = " \\note The tree does **not** take ownership of the geometry or the item."]
    pub fn GEOSSTRtree_insert(
        tree: *mut GEOSSTRtree,
        g: *const GEOSGeometry,
        item: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " Query an \\ref GEOSSTRtree for items intersecting a specified envelope"]
    #[doc = ""]
    #[doc = " \\param tree the \\ref GEOSSTRtree to search"]
    #[doc = " \\param g a GEOSGeomety from which a query envelope will be extracted"]
    #[doc = " \\param callback a function to be executed for each item in the tree whose envelope intersects"]
    #[doc = "            the envelope of 'g'.  The callback function should take two parameters: a void"]
    #[doc = "            pointer representing the located item in the tree, and a void userdata pointer."]
    #[doc = " \\param userdata an optional pointer to pe passed to 'callback' as an argument"]
    pub fn GEOSSTRtree_query(
        tree: *mut GEOSSTRtree,
        g: *const GEOSGeometry,
        callback: GEOSQueryCallback,
        userdata: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " Returns the nearest item in the \\ref GEOSSTRtree to the supplied geometry."]
    #[doc = " All items in the tree MUST be of type \\ref GEOSGeometry."]
    #[doc = " If this is not the case, use GEOSSTRtree_nearest_generic() instead."]
    #[doc = ""]
    #[doc = " \\param tree the \\ref GEOSSTRtree to search"]
    #[doc = " \\param geom the geometry with which the tree should be queried"]
    #[doc = " \\return a const pointer to the nearest \\ref GEOSGeometry in the tree to 'geom', or NULL in"]
    #[doc = "            case of exception"]
    pub fn GEOSSTRtree_nearest(
        tree: *mut GEOSSTRtree,
        geom: *const GEOSGeometry,
    ) -> *const GEOSGeometry;
}
extern "C" {
    #[doc = " Returns the nearest item in the \\ref GEOSSTRtree to the supplied item"]
    #[doc = ""]
    #[doc = " \\param tree the STRtree to search"]
    #[doc = " \\param item the item with which the tree should be queried"]
    #[doc = " \\param itemEnvelope a GEOSGeometry having the bounding box of 'item'"]
    #[doc = " \\param distancefn a function that can compute the distance between two items"]
    #[doc = "            in the STRtree.  The function should return zero in case of error,"]
    #[doc = "            and should store the computed distance to the location pointed to by"]
    #[doc = "            the 'distance' argument.  The computed distance between two items"]
    #[doc = "            must not exceed the Cartesian distance between their envelopes."]
    #[doc = " \\param userdata optional pointer to arbitrary data; will be passed to distancefn"]
    #[doc = "            each time it is called."]
    #[doc = " \\return a const pointer to the nearest item in the tree to 'item', or NULL in"]
    #[doc = "            case of exception"]
    pub fn GEOSSTRtree_nearest_generic(
        tree: *mut GEOSSTRtree,
        item: *const libc::c_void,
        itemEnvelope: *const GEOSGeometry,
        distancefn: GEOSDistanceCallback,
        userdata: *mut libc::c_void,
    ) -> *const libc::c_void;
}
extern "C" {
    #[doc = " Iterate over all items in the \\ref GEOSSTRtree."]
    #[doc = ""]
    #[doc = " \\param tree the STRtree over which to iterate"]
    #[doc = " \\param callback a function to be executed for each item in the tree."]
    #[doc = " \\param userdata payload to pass the callback function."]
    pub fn GEOSSTRtree_iterate(
        tree: *mut GEOSSTRtree,
        callback: GEOSQueryCallback,
        userdata: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = " Removes an item from the \\ref GEOSSTRtree"]
    #[doc = ""]
    #[doc = " \\param tree the STRtree from which to remove an item"]
    #[doc = " \\param g the envelope of the item to remove"]
    #[doc = " \\param item the item to remove"]
    #[doc = " \\return 0 if the item was not removed;"]
    #[doc = "         1 if the item was removed;"]
    #[doc = "         2 if an exception occurred"]
    pub fn GEOSSTRtree_remove(
        tree: *mut GEOSSTRtree,
        g: *const GEOSGeometry,
        item: *mut libc::c_void,
    ) -> libc::c_char;
}
extern "C" {
    #[doc = " Frees all the memory associated with a \\ref GEOSSTRtree."]
    #[doc = " Only the tree is freed. The geometries and items fed into"]
    #[doc = " GEOSSTRtree_insert() are not owned by the tree, and are"]
    #[doc = " still left to the caller to manage."]
    pub fn GEOSSTRtree_destroy(tree: *mut GEOSSTRtree);
}
extern "C" {
    #[doc = " Computes the coordinate where two line segments intersect, if any"]
    #[doc = ""]
    #[doc = " \\param[in] ax0 x-coordinate of 1st point in 1st segment"]
    #[doc = " \\param[in] ay0 y-coordinate of 1st point in 1st segment"]
    #[doc = " \\param[in] ax1 x-coordinate of 2nd point in 1st segment"]
    #[doc = " \\param[in] ay1 y-coordinate of 2nd point in 1st segment"]
    #[doc = " \\param[in] bx0 x-coordinate of 1st point in 2nd segment"]
    #[doc = " \\param[in] by0 y-coordinate of 1st point in 2nd segment"]
    #[doc = " \\param[in] bx1 x-coordinate of 2nd point in 2nd segment"]
    #[doc = " \\param[in] by1 y-coordinate of 2nd point in 2nd segment"]
    #[doc = " \\param[out] cx x-coordinate of intersection point"]
    #[doc = " \\param[out] cy y-coordinate of intersection point"]
    #[doc = ""]
    #[doc = " \\return 0 on error, 1 on success, -1 if segments do not intersect"]
    pub fn GEOSSegmentIntersection(
        ax0: f64,
        ay0: f64,
        ax1: f64,
        ay1: f64,
        bx0: f64,
        by0: f64,
        bx1: f64,
        by1: f64,
        cx: *mut f64,
        cy: *mut f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " For the points formed by the six input ordinates,"]
    #[doc = " walking from A to B and then to P."]
    #[doc = " \\param Ax X coordinate of A"]
    #[doc = " \\param Ay Y coordinate of A"]
    #[doc = " \\param Bx X coordinate of B"]
    #[doc = " \\param By Y coordinate of B"]
    #[doc = " \\param Px X coordinate of P"]
    #[doc = " \\param Py Y coordinate of P"]
    #[doc = " \\return  -1 if reaching P takes a counter-clockwise (left) turn,"]
    #[doc = "           1 if reaching P takes a clockwise (right) turn,"]
    #[doc = "           0 if P is collinear with A-B"]
    pub fn GEOSOrientationIndex(
        Ax: f64,
        Ay: f64,
        Bx: f64,
        By: f64,
        Px: f64,
        Py: f64,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Allocate a new \\ref GEOSWKTReader."]
    #[doc = " \\returns a new reader. Caller must free with GEOSWKTReader_destroy()"]
    pub fn GEOSWKTReader_create() -> *mut GEOSWKTReader;
}
extern "C" {
    #[doc = " Free the memory associated with a \\ref GEOSWKTReader."]
    #[doc = " \\param reader The reader to destroy."]
    pub fn GEOSWKTReader_destroy(reader: *mut GEOSWKTReader);
}
extern "C" {
    #[doc = " Use a reader to parse the well-known text representation of"]
    #[doc = " a geometry, and return an allocated geometry."]
    #[doc = " \\param reader A WKT reader object, caller retains ownership"]
    #[doc = " \\param wkt The WKT string to parse, caller retains ownership"]
    #[doc = " \\return A \\ref GEOSGeometry, caller to free with GEOSGeom_destroy())"]
    pub fn GEOSWKTReader_read(
        reader: *mut GEOSWKTReader,
        wkt: *const libc::c_char,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Allocate a new \\ref GEOSWKTWriter."]
    #[doc = " \\returns a new writer. Caller must free with GEOSWKTWriter_destroy()"]
    pub fn GEOSWKTWriter_create() -> *mut GEOSWKTWriter;
}
extern "C" {
    #[doc = " Free the memory associated with a \\ref GEOSWKTWriter."]
    #[doc = " \\param writer The writer to destroy."]
    pub fn GEOSWKTWriter_destroy(writer: *mut GEOSWKTWriter);
}
extern "C" {
    #[doc = " Writes out the well-known text representation of a geometry,"]
    #[doc = " using the trim, rounding and dimension settings of the writer."]
    #[doc = " \\param writer A \\ref GEOSWKTWriter."]
    #[doc = " \\param g Input geometry"]
    #[doc = " \\return A newly allocated string containing the WKT output or NULL on exception."]
    #[doc = " Caller must free with GEOSFree()"]
    pub fn GEOSWKTWriter_write(
        writer: *mut GEOSWKTWriter,
        g: *const GEOSGeometry,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " Sets the number trimming option on a \\ref GEOSWKTWriter."]
    #[doc = " With trim set to 1, the writer will strip trailing 0's from"]
    #[doc = " the output coordinates. With 0, all coordinates will be"]
    #[doc = " padded with 0's out to the rounding precision."]
    #[doc = " \\param writer A \\ref GEOSWKTWriter."]
    #[doc = " \\param trim The trimming behaviour to set, 1 for 'on', 0 for 'off', default 'off'"]
    pub fn GEOSWKTWriter_setTrim(writer: *mut GEOSWKTWriter, trim: libc::c_char);
}
extern "C" {
    #[doc = " Sets the number places after the decimal to output in"]
    #[doc = " WKT."]
    #[doc = " \\param writer A \\ref GEOSWKTWriter."]
    #[doc = " \\param precision The desired precision, default 16."]
    pub fn GEOSWKTWriter_setRoundingPrecision(writer: *mut GEOSWKTWriter, precision: libc::c_int);
}
extern "C" {
    #[doc = " Sets whether or not to write out XY or XYZ coordinates."]
    #[doc = " Legal values are 2 or 3."]
    #[doc = " \\param writer A \\ref GEOSWKTWriter."]
    #[doc = " \\param dim The desired dimension, default 2."]
    pub fn GEOSWKTWriter_setOutputDimension(writer: *mut GEOSWKTWriter, dim: libc::c_int);
}
extern "C" {
    #[doc = " Reads the current output dimension from a \\ref GEOSWKTWriter."]
    #[doc = " \\param writer A \\ref GEOSWKTWriter."]
    #[doc = " \\return The current dimension."]
    pub fn GEOSWKTWriter_getOutputDimension(writer: *mut GEOSWKTWriter) -> libc::c_int;
}
extern "C" {
    #[doc = " Sets the format for 3D outputs. The \"old 3D\" format does not"]
    #[doc = " include a dimensionality tag, eg. \"POINT(1 2 3)\" while the new (ISO)"]
    #[doc = " format does includes a tag, eg \"POINT Z (1 2 3)\"."]
    #[doc = " \\param writer A \\ref GEOSWKTWriter."]
    #[doc = " \\param useOld3D True to use the old format, false is the default."]
    pub fn GEOSWKTWriter_setOld3D(writer: *mut GEOSWKTWriter, useOld3D: libc::c_int);
}
extern "C" {
    #[doc = " Allocate a new \\ref GEOSWKBReader."]
    #[doc = " \\returns a new reader. Caller must free with GEOSWKBReader_destroy()"]
    pub fn GEOSWKBReader_create() -> *mut GEOSWKBReader;
}
extern "C" {
    #[doc = " Free the memory associated with a \\ref GEOSWKBReader."]
    #[doc = " \\param reader The reader to destroy."]
    pub fn GEOSWKBReader_destroy(reader: *mut GEOSWKBReader);
}
extern "C" {
    #[doc = " Read a geometry from a well-known binary buffer."]
    #[doc = " \\param reader A \\ref GEOSWKBReader"]
    #[doc = " \\param wkb A pointer to the buffer to read from"]
    #[doc = " \\param size The number of bytes of data in the buffer"]
    #[doc = " \\return A \\ref GEOSGeometry built from the WKB, or NULL on exception."]
    pub fn GEOSWKBReader_read(
        reader: *mut GEOSWKBReader,
        wkb: *const libc::c_uchar,
        size: usize,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Read a geometry from a **hex encoded** well-known binary buffer."]
    #[doc = " \\param reader A \\ref GEOSWKBReader"]
    #[doc = " \\param hex A pointer to the buffer to read from"]
    #[doc = " \\param size The number of bytes of data in the buffer"]
    #[doc = " \\return A \\ref GEOSGeometry built from the HEX WKB, or NULL on exception."]
    pub fn GEOSWKBReader_readHEX(
        reader: *mut GEOSWKBReader,
        hex: *const libc::c_uchar,
        size: usize,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Allocate a new \\ref GEOSWKBWriter."]
    #[doc = " \\returns a new writer. Caller must free with GEOSWKBWriter_destroy()"]
    pub fn GEOSWKBWriter_create() -> *mut GEOSWKBWriter;
}
extern "C" {
    #[doc = " Free the memory associated with a \\ref GEOSWKBWriter."]
    #[doc = " \\param writer The writer to destroy."]
    pub fn GEOSWKBWriter_destroy(writer: *mut GEOSWKBWriter);
}
extern "C" {
    #[doc = " Write out the WKB representation of a geometry."]
    #[doc = " \\param writer The \\ref GEOSWKBWriter controlling the"]
    #[doc = " writing."]
    #[doc = " \\param g Geometry to convert to WKB"]
    #[doc = " \\param size Pointer to write the size of the final output WKB to"]
    #[doc = " \\return The WKB representation. Caller must free with GEOSFree()"]
    pub fn GEOSWKBWriter_write(
        writer: *mut GEOSWKBWriter,
        g: *const GEOSGeometry,
        size: *mut usize,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    #[doc = " Write out the **hex** WKB representation of a geometry."]
    #[doc = " \\param writer The \\ref GEOSWKBWriter controlling the"]
    #[doc = " writing."]
    #[doc = " \\param g Geometry to convert to WKB"]
    #[doc = " \\param size Pointer to write the size of the final output WKB to"]
    #[doc = " \\return The HEX WKB representation. Caller must free with GEOSFree()"]
    pub fn GEOSWKBWriter_writeHEX(
        writer: *mut GEOSWKBWriter,
        g: *const GEOSGeometry,
        size: *mut usize,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    #[doc = " Read the current output dimension of the writer."]
    #[doc = " Either 2 or 3 dimensions."]
    #[doc = " Return current number of dimensions."]
    #[doc = " \\param writer The writer to read from."]
    #[doc = " \\return Number of dimensions (2 or 3)"]
    pub fn GEOSWKBWriter_getOutputDimension(writer: *const GEOSWKBWriter) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the output dimensionality of the writer. Either"]
    #[doc = " 2 or 3 dimensions."]
    #[doc = " \\param writer The writer to read from."]
    #[doc = " \\param newDimension The dimensionality desired"]
    pub fn GEOSWKBWriter_setOutputDimension(writer: *mut GEOSWKBWriter, newDimension: libc::c_int);
}
extern "C" {
    #[doc = " Find whether the writer will use WKB"]
    #[doc = " [byte order](https://en.wikipedia.org/wiki/Endianness)"]
    #[doc = " that is big or little endian."]
    #[doc = " The return value is a member of \\ref GEOSWKBByteOrders."]
    #[doc = " \\param writer The writer to read byte order from"]
    #[doc = " \\return The current byte order"]
    pub fn GEOSWKBWriter_getByteOrder(writer: *const GEOSWKBWriter) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the output byte order of the writer, using"]
    #[doc = " a value from \\ref GEOSWKBByteOrders enum."]
    #[doc = " \\param writer The writer to set byte order on"]
    #[doc = " \\param byteOrder Desired byte order"]
    pub fn GEOSWKBWriter_setByteOrder(writer: *mut GEOSWKBWriter, byteOrder: libc::c_int);
}
extern "C" {
    #[doc = " Find whether the writer will use"]
    #[doc = " [WKB](https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry#Well-known_binary)"]
    #[doc = " that is ISO flavor or \"extended\" flavor. The flavor"]
    #[doc = " determines how extra dimensionality is encoded with the"]
    #[doc = " type number, and whether SRID can be included in the WKB."]
    #[doc = " ISO flavor does not support SRID embedding. ISO flavor"]
    #[doc = " is \"more standard\" for 3D output. GEOS can read both flavors."]
    #[doc = " The return value is a member of \\ref GEOSWKBFlavors."]
    #[doc = " \\param writer The writer to read flavor from"]
    #[doc = " \\return The current flavor"]
    pub fn GEOSWKBWriter_getFlavor(writer: *const GEOSWKBWriter) -> libc::c_int;
}
extern "C" {
    #[doc = " Set the output flavor of the writer, using"]
    #[doc = " a value from \\ref GEOSWKBFlavors enum."]
    #[doc = " \\param writer The writer to set flavor on"]
    #[doc = " \\param flavor Desired flavor"]
    pub fn GEOSWKBWriter_setFlavor(writer: *mut GEOSWKBWriter, flavor: libc::c_int);
}
extern "C" {
    #[doc = " Read the current SRID embedding value from the writer."]
    #[doc = " \\param writer The writer to check SRID value on"]
    pub fn GEOSWKBWriter_getIncludeSRID(writer: *const GEOSWKBWriter) -> libc::c_char;
}
extern "C" {
    #[doc = " Specify whether SRID values should be output in WKB."]
    #[doc = " Many WKB readers do not support SRID values, use with caution."]
    #[doc = " \\param writer The writer to set SRID output on"]
    #[doc = " \\param writeSRID Set to 1 to include SRID, 0 otherwise"]
    pub fn GEOSWKBWriter_setIncludeSRID(writer: *mut GEOSWKBWriter, writeSRID: libc::c_char);
}
extern "C" {
    #[doc = " Allocate a new \\ref GEOSGeoJSONReader."]
    #[doc = " \\returns a new reader. Caller must free with GEOSGeoJSONReader_destroy()"]
    pub fn GEOSGeoJSONReader_create() -> *mut GEOSGeoJSONReader;
}
extern "C" {
    #[doc = " Free the memory associated with a \\ref GEOSGeoJSONReader."]
    #[doc = " \\param reader The reader to destroy."]
    pub fn GEOSGeoJSONReader_destroy(reader: *mut GEOSGeoJSONReader);
}
extern "C" {
    #[doc = " Use a reader to parse a GeoJSON. A single geometry or feature is"]
    #[doc = " converted into a geometry. A featurecollection is converted into a"]
    #[doc = " geometrycollection. Feature properties are not read."]
    #[doc = " \\param reader A GeoJSON reader object, caller retains ownership"]
    #[doc = " \\param geojson The json string to parse, caller retains ownership"]
    #[doc = " \\return A \\ref GEOSGeometry, caller to free with GEOSGeom_destroy())"]
    pub fn GEOSGeoJSONReader_readGeometry(
        reader: *mut GEOSGeoJSONReader,
        geojson: *const libc::c_char,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " Allocate a new \\ref GEOSGeoJSONWriter."]
    #[doc = " \\returns a new writer. Caller must free with GEOSGeoJSONWriter_destroy()"]
    pub fn GEOSGeoJSONWriter_create() -> *mut GEOSGeoJSONWriter;
}
extern "C" {
    #[doc = " Free the memory associated with a \\ref GEOSGeoJSONWriter."]
    #[doc = " \\param writer The writer to destroy."]
    pub fn GEOSGeoJSONWriter_destroy(writer: *mut GEOSGeoJSONWriter);
}
extern "C" {
    #[doc = " Write out the GeoJSON representation of a geometry. Note that writing a GeoJSON"]
    #[doc = " Feature or FeatureCollection is unsupported through the GEOS C API."]
    #[doc = " \\param writer A GeoJSON reader object, caller retains ownership."]
    #[doc = " \\param g The geometry to convert, caller retains ownership."]
    #[doc = " \\param indent The indentation used. Use -1 for no formatting."]
    #[doc = " \\return A char pointer, caller to free with GEOSFree())"]
    pub fn GEOSGeoJSONWriter_writeGeometry(
        writer: *mut GEOSGeoJSONWriter,
        g: *const GEOSGeometry,
        indent: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " \\deprecated in 3.3.0, use GEOSOffsetCurve() instead"]
    pub fn GEOSSingleSidedBuffer(
        g: *const GEOSGeometry,
        width: f64,
        quadsegs: libc::c_int,
        joinStyle: libc::c_int,
        mitreLimit: f64,
        leftSide: libc::c_int,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\deprecated in 3.3.0, use GEOSOffsetCurve() instead"]
    pub fn GEOSSingleSidedBuffer_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        width: f64,
        quadsegs: libc::c_int,
        joinStyle: libc::c_int,
        mitreLimit: f64,
        leftSide: libc::c_int,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\deprecated in 3.5.0. Use GEOS_init_r() and set the message handlers using"]
    #[doc = " GEOSContext_setNoticeHandler_r() and/or GEOSContext_setErrorHandler_r()"]
    pub fn initGEOS_r(
        notice_function: GEOSMessageHandler,
        error_function: GEOSMessageHandler,
    ) -> GEOSContextHandle_t;
}
extern "C" {
    #[doc = " \\deprecated in 3.5.0, replaced by GEOS_finish_r()"]
    pub fn finishGEOS_r(handle: GEOSContextHandle_t);
}
extern "C" {
    #[doc = " \\deprecated use \\ref GEOSWKTReader and GEOSWKTReader_read_r()"]
    pub fn GEOSGeomFromWKT_r(
        handle: GEOSContextHandle_t,
        wkt: *const libc::c_char,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\deprecated use \\ref GEOSWKTWriter and GEOSWKTWriter_write_r()"]
    pub fn GEOSGeomToWKT_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " \\deprecated use \\ref GEOSWKBWriter and GEOSWKBWriter_getOutputDimension_r()"]
    pub fn GEOS_getWKBOutputDims_r(handle: GEOSContextHandle_t) -> libc::c_int;
}
extern "C" {
    #[doc = " \\deprecated use \\ref GEOSWKBWriter and GEOSWKBWriter_setOutputDimension_r()"]
    pub fn GEOS_setWKBOutputDims_r(
        handle: GEOSContextHandle_t,
        newDims: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\deprecated use \\ref GEOSWKBWriter and GEOSWKBWriter_getByteOrder_r()"]
    pub fn GEOS_getWKBByteOrder_r(handle: GEOSContextHandle_t) -> libc::c_int;
}
extern "C" {
    #[doc = " \\deprecated use \\ref GEOSWKBWriter and GEOSWKBWriter_setByteOrder_r()"]
    pub fn GEOS_setWKBByteOrder_r(
        handle: GEOSContextHandle_t,
        byteOrder: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\deprecated use \\ref GEOSWKBReader and GEOSWKBReader_read_r()"]
    pub fn GEOSGeomFromWKB_buf_r(
        handle: GEOSContextHandle_t,
        wkb: *const libc::c_uchar,
        size: usize,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\deprecated use \\ref GEOSWKBWriter and GEOSWKBWriter_write_r()"]
    pub fn GEOSGeomToWKB_buf_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        size: *mut usize,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    #[doc = " \\deprecated use \\ref GEOSWKBReader and GEOSWKBReader_readHEX_r()"]
    pub fn GEOSGeomFromHEX_buf_r(
        handle: GEOSContextHandle_t,
        hex: *const libc::c_uchar,
        size: usize,
    ) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\deprecated use \\ref GEOSWKBWriter and GEOSWKBWriter_writeHEX_r()"]
    pub fn GEOSGeomToHEX_buf_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
        size: *mut usize,
    ) -> *mut libc::c_uchar;
}
extern "C" {
    #[doc = " \\deprecated use \\ref GEOSWKTReader and GEOSWKTReader_read_r()"]
    pub fn GEOSGeomFromWKT(wkt: *const libc::c_char) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\deprecated use \\ref GEOSWKTWriter and GEOSWKTWriter_write()"]
    pub fn GEOSGeomToWKT(g: *const GEOSGeometry) -> *mut libc::c_char;
}
extern "C" {
    #[doc = " \\deprecated use \\ref GEOSWKBWriter and GEOS_getWKBOutputDims()"]
    pub fn GEOS_getWKBOutputDims() -> libc::c_int;
}
extern "C" {
    #[doc = " \\deprecated use \\ref GEOSWKBWriter and GEOS_setWKBOutputDims()"]
    pub fn GEOS_setWKBOutputDims(newDims: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " \\deprecated use \\ref GEOSWKBWriter and GEOSWKBWriter_getByteOrder()"]
    pub fn GEOS_getWKBByteOrder() -> libc::c_int;
}
extern "C" {
    #[doc = " \\deprecated use \\ref GEOSWKBWriter and GEOSWKBWriter_setByteOrder()"]
    pub fn GEOS_setWKBByteOrder(byteOrder: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " \\deprecated use \\ref GEOSWKBReader and GEOSWKBWriter_read()"]
    pub fn GEOSGeomFromWKB_buf(wkb: *const libc::c_uchar, size: usize) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\deprecated use \\ref GEOSWKBWriter and GEOSWKBWriter_write()"]
    pub fn GEOSGeomToWKB_buf(g: *const GEOSGeometry, size: *mut usize) -> *mut libc::c_uchar;
}
extern "C" {
    #[doc = " \\deprecated use \\ref GEOSWKBReader and GEOSWKBWriter_readHEX()"]
    pub fn GEOSGeomFromHEX_buf(hex: *const libc::c_uchar, size: usize) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\deprecated use \\ref GEOSWKBWriter and GEOSWKBWriter_writeHEX()"]
    pub fn GEOSGeomToHEX_buf(g: *const GEOSGeometry, size: *mut usize) -> *mut libc::c_uchar;
}
extern "C" {
    #[doc = " \\deprecated in 3.3.0: use GEOSUnaryUnion() instead"]
    pub fn GEOSUnionCascaded(g: *const GEOSGeometry) -> *mut GEOSGeometry;
}
extern "C" {
    #[doc = " \\deprecated in 3.3.0: use GEOSUnaryUnion_r() instead"]
    pub fn GEOSUnionCascaded_r(
        handle: GEOSContextHandle_t,
        g: *const GEOSGeometry,
    ) -> *mut GEOSGeometry;
}
